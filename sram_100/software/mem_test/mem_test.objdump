
mem_test.elf:     file format elf32-littlenios2
mem_test.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x02000020

Program Header:
    LOAD off    0x00001000 vaddr 0x02000000 paddr 0x02000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x02000020 paddr 0x02000020 align 2**12
         filesz 0x00001f34 memsz 0x00001f34 flags r-x
    LOAD off    0x00002f54 vaddr 0x02001f54 paddr 0x02002110 align 2**12
         filesz 0x000001bc memsz 0x000001bc flags rw-
    LOAD off    0x000032cc vaddr 0x020022cc paddr 0x020022cc align 2**12
         filesz 0x00000000 memsz 0x00000010 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  02000000  02000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00001818  02000020  02000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000071c  02001838  02001838  00002838  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       000001bc  02001f54  02002110  00002f54  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          00000010  020022cc  020022cc  000032cc  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  00003110  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000390  00000000  00000000  00003138  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007558  00000000  00000000  000034c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000021b8  00000000  00000000  0000aa20  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000026d5  00000000  00000000  0000cbd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000004b8  00000000  00000000  0000f2b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000014d6  00000000  00000000  0000f768  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002209  00000000  00000000  00010c3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000030  00000000  00000000  00012e48  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000380  00000000  00000000  00012e78  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  0001462a  2**0
                  CONTENTS, READONLY
 16 .cpu          00000003  00000000  00000000  0001462d  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  00014630  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  00014631  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  00014632  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  00014636  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  0001463a  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  0001463e  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  00014647  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  00014650  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000d  00000000  00000000  00014659  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000018  00000000  00000000  00014666  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0003e66d  00000000  00000000  0001467e  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
02000000 l    d  .entry	00000000 .entry
02000020 l    d  .text	00000000 .text
02001838 l    d  .rodata	00000000 .rodata
02001f54 l    d  .rwdata	00000000 .rwdata
020022cc l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../mem_test_bsp/obj/HAL/src/crt0.o
02000068 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 memtest_small.c
00000000 l    df *ABS*	00000000 impure.c
02001f54 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 ctype_.c
02001da2 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
02001364 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_getchar.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
02002034 l     O .rwdata	0000002c Green_LEDs
02002060 l     O .rwdata	0000002c Pushbuttons
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
02001778 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 
020007e0 g     F .text	0000001c putchar
020015dc g     F .text	0000002c alt_main
020007fc g     F .text	00000080 _puts_r
02002110 g       *ABS*	00000000 __flash_rwdata_start
020006d0 g     F .text	0000004c printf
04000000 g       *ABS*	00000000 __alt_mem_sram
0200006c g     F .text	0000009c GetInputString
020020f4 g     O .rwdata	00000004 jtag_uart
00000000  w      *UND*	00000000 __errno
02000000 g     F .entry	0000001c __reset
02000020 g       *ABS*	00000000 __flash_exceptions_start
020022cc g     O .bss	00000004 errno
020022d4 g     O .bss	00000004 alt_argv
0200a0e4 g       *ABS*	00000000 _gp
0200208c g     O .rwdata	00000030 alt_fd_list
020007d8 g     F .text	00000008 _putchar_r
0200087c g     F .text	00000014 puts
020016d0 g     F .text	0000005c altera_avalon_jtag_uart_read
02000694 g     F .text	0000003c _printf_r
02001484 g     F .text	00000008 __udivsi3
02001800 g     F .text	00000038 alt_icache_flush
020020f8 g     O .rwdata	00000004 alt_max_fd
020020e8 g     O .rwdata	00000004 _global_impure_ptr
020022dc g       *ABS*	00000000 __bss_end
02001494 g     F .text	00000044 alt_getchar
020020f0 g     O .rwdata	00000004 __ctype_ptr
02000b0c g     F .text	00000024 strtol
020020bc g     O .rwdata	00000028 alt_dev_null
02001760 g     F .text	00000018 alt_dcache_flush_all
02002110 g       *ABS*	00000000 __ram_rwdata_end
020020fc g     O .rwdata	00000008 alt_dev_list
02001608 g     F .text	00000068 write
02000778 g     F .text	00000060 _putc_r
02001f54 g       *ABS*	00000000 __ram_rodata_end
0200148c g     F .text	00000008 __umodsi3
020022dc g       *ABS*	00000000 end
04000000 g       *ABS*	00000000 __alt_stack_pointer
0200172c g     F .text	00000034 altera_avalon_jtag_uart_write
02000b30 g     F .text	000006c4 ___vfprintf_internal_r
02000020 g     F .text	0000004c _start
02001690 g     F .text	00000040 alt_sys_init
02001f54 g       *ABS*	00000000 __ram_rwdata_start
02001838 g       *ABS*	00000000 __ram_rodata_start
020022dc g       *ABS*	00000000 __alt_stack_base
02001780 g     F .text	0000006c alt_dev_llist_insert
02001218 g     F .text	000000e0 __sfvwrite_small_dev
020022cc g       *ABS*	00000000 __bss_start
02000108 g     F .text	0000058c main
020022d0 g     O .bss	00000004 alt_envp
020008b8 g     F .text	00000254 _strtol_r
0200210c g     O .rwdata	00000004 alt_errno
0200071c g     F .text	0000005c putc
020013d8 g     F .text	00000050 __divsi3
02001838 g       *ABS*	00000000 __flash_rodata_start
02001670 g     F .text	00000020 alt_irq_init
020012f8 g     F .text	0000006c _write_r
020020ec g     O .rwdata	00000004 _impure_ptr
020022d8 g     O .bss	00000004 alt_argc
02002104 g     O .rwdata	00000008 alt_fs_list
02000020 g       *ABS*	00000000 __ram_exceptions_start
02002110 g       *ABS*	00000000 _edata
020022dc g       *ABS*	00000000 _end
02000020 g       *ABS*	00000000 __ram_exceptions_end
020017f8 g     F .text	00000008 altera_nios2_qsys_irq_init
02001428 g     F .text	0000005c __modsi3
04000000 g       *ABS*	00000000 __alt_data_end
02000000 g       *ABS*	00000000 __alt_mem_sdram
02001ca1 g     O .rodata	00000101 _ctype_
0200001c g       .entry	00000000 _exit
02000890 g     F .text	00000028 strlen
020017ec g     F .text	0000000c alt_icache_flush_all
020020e4 g     O .rwdata	00000004 green_LED_ptr
020011f4 g     F .text	00000024 __vfprintf_internal
020014d8 g     F .text	00000104 alt_load



Disassembly of section .entry:

02000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 2000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 2000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 2000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 200000c:	00bffd16 	blt	zero,r2,2000004 <__alt_data_end+0xfe000004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 2000010:	00408034 	movhi	at,512
    ori r1, r1, %lo(_start)
 2000014:	08400814 	ori	at,at,32
    jmp r1
 2000018:	0800683a 	jmp	at

0200001c <_exit>:
 200001c:	00000000 	call	0 <__alt_mem_sdram-0x2000000>

Disassembly of section .text:

02000020 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 2000020:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 2000024:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 2000028:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 200002c:	00bffd16 	blt	zero,r2,2000024 <__alt_data_end+0xfe000024>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 2000030:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 2000034:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 2000038:	06808034 	movhi	gp,512
    ori gp, gp, %lo(_gp)
 200003c:	d6a83914 	ori	gp,gp,41188
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 2000040:	00808034 	movhi	r2,512
    ori r2, r2, %lo(__bss_start)
 2000044:	1088b314 	ori	r2,r2,8908

    movhi r3, %hi(__bss_end)
 2000048:	00c08034 	movhi	r3,512
    ori r3, r3, %lo(__bss_end)
 200004c:	18c8b714 	ori	r3,r3,8924

    beq r2, r3, 1f
 2000050:	10c00326 	beq	r2,r3,2000060 <_start+0x40>

0:
    stw zero, (r2)
 2000054:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 2000058:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 200005c:	10fffd36 	bltu	r2,r3,2000054 <__alt_data_end+0xfe000054>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 2000060:	20014d80 	call	20014d8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 2000064:	20015dc0 	call	20015dc <alt_main>

02000068 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 2000068:	003fff06 	br	2000068 <__alt_data_end+0xfe000068>

0200006c <GetInputString>:
*           returns the string, minus any '\r' characters it 
*           encounters.
*
******************************************************************/
void GetInputString( char* entry, int size, FILE * stream )
{
 200006c:	defff804 	addi	sp,sp,-32
 2000070:	dd800615 	stw	r22,24(sp)
 2000074:	dd400515 	stw	r21,20(sp)
 2000078:	dd000415 	stw	r20,16(sp)
 200007c:	dcc00315 	stw	r19,12(sp)
 2000080:	dc800215 	stw	r18,8(sp)
 2000084:	dc000015 	stw	r16,0(sp)
 2000088:	dfc00715 	stw	ra,28(sp)
 200008c:	dc400115 	stw	r17,4(sp)
 2000090:	2027883a 	mov	r19,r4
 2000094:	2825883a 	mov	r18,r5
  int i;
  int ch = 0;
  
  for(i = 0; (ch != '\n') && (i < size); )
 2000098:	0021883a 	mov	r16,zero
  {
    if( (ch = alt_getchar()) != '\r')
 200009c:	05000344 	movi	r20,13
    {
      putchar(ch);
 20000a0:	05408034 	movhi	r21,512
 20000a4:	ad483b04 	addi	r21,r21,8428
void GetInputString( char* entry, int size, FILE * stream )
{
  int i;
  int ch = 0;
  
  for(i = 0; (ch != '\n') && (i < size); )
 20000a8:	05800284 	movi	r22,10
 20000ac:	00000b06 	br	20000dc <GetInputString+0x70>
  {
    if( (ch = alt_getchar()) != '\r')
 20000b0:	20014940 	call	2001494 <alt_getchar>
 20000b4:	1023883a 	mov	r17,r2
 20000b8:	15000826 	beq	r2,r20,20000dc <GetInputString+0x70>
    {
      putchar(ch);
 20000bc:	a8800017 	ldw	r2,0(r21)
 20000c0:	8809883a 	mov	r4,r17
 20000c4:	11400217 	ldw	r5,8(r2)
 20000c8:	200071c0 	call	200071c <putc>
      entry[i] = ch;
 20000cc:	9c05883a 	add	r2,r19,r16
 20000d0:	14400005 	stb	r17,0(r2)
      i++;
 20000d4:	84000044 	addi	r16,r16,1
void GetInputString( char* entry, int size, FILE * stream )
{
  int i;
  int ch = 0;
  
  for(i = 0; (ch != '\n') && (i < size); )
 20000d8:	8d800126 	beq	r17,r22,20000e0 <GetInputString+0x74>
 20000dc:	84bff416 	blt	r16,r18,20000b0 <__alt_data_end+0xfe0000b0>
      putchar(ch);
      entry[i] = ch;
      i++;
    }
  }
}
 20000e0:	dfc00717 	ldw	ra,28(sp)
 20000e4:	dd800617 	ldw	r22,24(sp)
 20000e8:	dd400517 	ldw	r21,20(sp)
 20000ec:	dd000417 	ldw	r20,16(sp)
 20000f0:	dcc00317 	ldw	r19,12(sp)
 20000f4:	dc800217 	ldw	r18,8(sp)
 20000f8:	dc400117 	ldw	r17,4(sp)
 20000fc:	dc000017 	ldw	r16,0(sp)
 2000100:	dec00804 	addi	sp,sp,32
 2000104:	f800283a 	ret

02000108 <main>:
*  Purpose: Continually prints the menu and performs the actions
*           requested by the user.
* 
******************************************************************/
int main(void)
{
 2000108:	defff204 	addi	sp,sp,-56
*  Purpose: Prints the menu header.
*
******************************************************************/
static void MenuHeader(void)
{
  printf("\n\n");
 200010c:	01008034 	movhi	r4,512
 2000110:	21060e04 	addi	r4,r4,6200
*  Purpose: Continually prints the menu and performs the actions
*           requested by the user.
* 
******************************************************************/
int main(void)
{
 2000114:	dfc00d15 	stw	ra,52(sp)
 2000118:	ddc00c15 	stw	r23,48(sp)
 200011c:	dd800b15 	stw	r22,44(sp)
 2000120:	dd400a15 	stw	r21,40(sp)
 2000124:	dd000915 	stw	r20,36(sp)
 2000128:	dc800715 	stw	r18,28(sp)
 200012c:	dcc00815 	stw	r19,32(sp)
 2000130:	dc400615 	stw	r17,24(sp)
 2000134:	dc000515 	stw	r16,20(sp)
*  Purpose: Prints the menu header.
*
******************************************************************/
static void MenuHeader(void)
{
  printf("\n\n");
 2000138:	200087c0 	call	200087c <puts>
  printf("             <---->   Nios II Memory Test.   <---->\n");
 200013c:	01008034 	movhi	r4,512
 2000140:	21060f04 	addi	r4,r4,6204
 2000144:	200087c0 	call	200087c <puts>
  printf("This software example tests the memory in your system to assure it\n");
 2000148:	01008034 	movhi	r4,512
 200014c:	21061c04 	addi	r4,r4,6256
 2000150:	200087c0 	call	200087c <puts>
  printf("is working properly.  This test is destructive to the contents of\n");
 2000154:	01008034 	movhi	r4,512
 2000158:	21062d04 	addi	r4,r4,6324
 200015c:	200087c0 	call	200087c <puts>
  printf("the memory it tests. Assure the memory being tested does not contain\n");
 2000160:	01008034 	movhi	r4,512
 2000164:	21063e04 	addi	r4,r4,6392
 2000168:	200087c0 	call	200087c <puts>
  printf("the executable or data sections of this code or the exception address\n");
 200016c:	01008034 	movhi	r4,512
 2000170:	21065004 	addi	r4,r4,6464
 2000174:	200087c0 	call	200087c <puts>
  printf("of the system.\n");
 2000178:	01008034 	movhi	r4,512
 200017c:	21066204 	addi	r4,r4,6536
 2000180:	056aaaf4 	movhi	r21,43691
 2000184:	ad6aaa84 	addi	r21,r21,-21846
    IOWR_32DIRECT(memory_base, offset, pattern);
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
 2000188:	05955574 	movhi	r22,21845
 200018c:	b5955544 	addi	r22,r22,21845
  printf("             <---->   Nios II Memory Test.   <---->\n");
  printf("This software example tests the memory in your system to assure it\n");
  printf("is working properly.  This test is destructive to the contents of\n");
  printf("the memory it tests. Assure the memory being tested does not contain\n");
  printf("the executable or data sections of this code or the exception address\n");
  printf("of the system.\n");
 2000190:	200087c0 	call	200087c <puts>
	  *(green_LED_ptr) =  0x01;


    printf("\nPress enter to continue or 'q' to quit.\n");
    ch = alt_getchar();
    putchar(ch);
 2000194:	05008034 	movhi	r20,512
 2000198:	a5083b04 	addi	r20,r20,8428
 200019c:	a825883a 	mov	r18,r21
 20001a0:	b02f883a 	mov	r23,r22

  MenuHeader();

  while (1)
  {
	  *(green_LED_ptr) =  0x01;
 20001a4:	d0a00017 	ldw	r2,-32768(gp)
 20001a8:	00c00044 	movi	r3,1


    printf("\nPress enter to continue or 'q' to quit.\n");
 20001ac:	01008034 	movhi	r4,512
 20001b0:	21066604 	addi	r4,r4,6552

  MenuHeader();

  while (1)
  {
	  *(green_LED_ptr) =  0x01;
 20001b4:	10c00015 	stw	r3,0(r2)


    printf("\nPress enter to continue or 'q' to quit.\n");
 20001b8:	200087c0 	call	200087c <puts>
    ch = alt_getchar();
 20001bc:	20014940 	call	2001494 <alt_getchar>
 20001c0:	1021883a 	mov	r16,r2
    putchar(ch);
 20001c4:	a0800017 	ldw	r2,0(r20)
 20001c8:	8009883a 	mov	r4,r16
 20001cc:	04408034 	movhi	r17,512
 20001d0:	8c483b04 	addi	r17,r17,8428
 20001d4:	11400217 	ldw	r5,8(r2)
 20001d8:	200071c0 	call	200071c <putc>
    if(ch == 'q' || ch == 'Q')
 20001dc:	00801c44 	movi	r2,113
 20001e0:	80811d26 	beq	r16,r2,2000658 <main+0x550>
 20001e4:	00801444 	movi	r2,81
 20001e8:	80811b26 	beq	r16,r2,2000658 <main+0x550>
    {
        printf( "\nExiting from Memory Test.\n");
        break;
    }
    else if (ch == '\n')
 20001ec:	00800284 	movi	r2,10
 20001f0:	80bfec1e 	bne	r16,r2,20001a4 <__alt_data_end+0xfe0001a4>
  char *pend;

  while(1)
  {
    /* Get the base address */
    printf("Base address to start memory test: (i.e. 0x800000)\n");
 20001f4:	01008034 	movhi	r4,512
 20001f8:	21067804 	addi	r4,r4,6624
 20001fc:	200087c0 	call	200087c <puts>
    printf(">");
 2000200:	01000f84 	movi	r4,62
 2000204:	20007e00 	call	20007e0 <putchar>

    GetInputString( line, sizeof(line), stdin );
 2000208:	88800017 	ldw	r2,0(r17)
 200020c:	d809883a 	mov	r4,sp
 2000210:	01400304 	movi	r5,12
 2000214:	11800117 	ldw	r6,4(r2)
 2000218:	200006c0 	call	200006c <GetInputString>
   
    /* Check the format to make sure it was entered as hex */
    
    if((*base_address = strtol(line, &pend, 16)) < 0)
 200021c:	d809883a 	mov	r4,sp
 2000220:	d9400404 	addi	r5,sp,16
 2000224:	01800404 	movi	r6,16
 2000228:	2000b0c0 	call	2000b0c <strtol>
 200022c:	1021883a 	mov	r16,r2
 2000230:	1000050e 	bge	r2,zero,2000248 <main+0x140>
    {
      printf("%s\n", line);
 2000234:	d809883a 	mov	r4,sp
 2000238:	200087c0 	call	200087c <puts>
      printf(" -ERROR: Invalid base address entered.  Address must be in the form '0x800000'\n\n");
 200023c:	01008034 	movhi	r4,512
 2000240:	21068504 	addi	r4,r4,6676
 2000244:	00001606 	br	20002a0 <main+0x198>
      continue;
    }
    
    /* Get the end address */
    printf("End Address:\n");
 2000248:	01008034 	movhi	r4,512
 200024c:	21069904 	addi	r4,r4,6756
 2000250:	200087c0 	call	200087c <puts>
    printf(">");
 2000254:	01000f84 	movi	r4,62
 2000258:	20007e00 	call	20007e0 <putchar>

    GetInputString( line, sizeof(line), stdin );
 200025c:	a0800017 	ldw	r2,0(r20)
 2000260:	d809883a 	mov	r4,sp
 2000264:	01400304 	movi	r5,12
 2000268:	11800117 	ldw	r6,4(r2)
 200026c:	200006c0 	call	200006c <GetInputString>
    
    /* Check the format to make sure it was entered as hex */
    if((*end_address = strtol(line, &pend, 16)) < 0)
 2000270:	d809883a 	mov	r4,sp
 2000274:	d9400404 	addi	r5,sp,16
 2000278:	01800404 	movi	r6,16
 200027c:	2000b0c0 	call	2000b0c <strtol>
 2000280:	1027883a 	mov	r19,r2
 2000284:	1000030e 	bge	r2,zero,2000294 <main+0x18c>
    {
      printf(" -ERROR: Invalid end address entered.  Address must be in the form '0x8FFFFF'\n\n");
 2000288:	01008034 	movhi	r4,512
 200028c:	21069d04 	addi	r4,r4,6772
 2000290:	00000306 	br	20002a0 <main+0x198>
      continue;
    }
    
    /* Make sure end address is greater than base address. */
    if (*end_address <= *base_address)
 2000294:	80800416 	blt	r16,r2,20002a8 <main+0x1a0>
    {
      printf(" -ERROR: End address must be greater than the start address\n\n");
 2000298:	01008034 	movhi	r4,512
 200029c:	2106b104 	addi	r4,r4,6852
 20002a0:	200087c0 	call	200087c <puts>
 20002a4:	003fd306 	br	20001f4 <__alt_data_end+0xfe0001f4>
  MemGetAddressRange(&memory_base, &memory_end);
  memory_size = (memory_end - memory_base);
//for (y=0; y<10000; y++)
//{

  printf("\n");
 20002a8:	01000284 	movi	r4,10
 20002ac:	20007e00 	call	20007e0 <putchar>
  printf("test=%d\n",y);
 20002b0:	0023883a 	mov	r17,zero
 20002b4:	01008034 	movhi	r4,512
 20002b8:	2106c104 	addi	r4,r4,6916
 20002bc:	880b883a 	mov	r5,r17
 20002c0:	20006d00 	call	20006d0 <printf>
 IOWR_32DIRECT(GREEN_LEDS_BASE, 0, y);
 20002c4:	00810834 	movhi	r2,1056
 20002c8:	10840004 	addi	r2,r2,4096
 20002cc:	14400035 	stwio	r17,0(r2)
  printf("Testing RAM from 0x%X to 0x%X\n", memory_base, (memory_base + memory_size));
 20002d0:	01008034 	movhi	r4,512
 20002d4:	2106c404 	addi	r4,r4,6928
 20002d8:	800b883a 	mov	r5,r16
 20002dc:	980d883a 	mov	r6,r19
 20002e0:	20006d00 	call	20006d0 <printf>
{
  volatile unsigned int pattern;
  unsigned int ret_code = 0x0;

  /* Perform a walking 1's test at the given address. */
  for (pattern = 1; pattern != 0; pattern <<= 1)
 20002e4:	00800044 	movi	r2,1
 20002e8:	00000a06 	br	2000314 <main+0x20c>
  {
    /* Write the test pattern. */
    IOWR_32DIRECT(address, 0, pattern);
 20002ec:	d8800317 	ldw	r2,12(sp)
 20002f0:	80800035 	stwio	r2,0(r16)

    /* Read it back (immediately is okay for this test). */
    if (IORD_32DIRECT(address, 0) != pattern)
 20002f4:	80c00037 	ldwio	r3,0(r16)
 20002f8:	d8800317 	ldw	r2,12(sp)
 20002fc:	18800326 	beq	r3,r2,200030c <main+0x204>
    {
      ret_code = pattern;
 2000300:	d9400317 	ldw	r5,12(sp)
  printf("Testing RAM from 0x%X to 0x%X\n", memory_base, (memory_base + memory_size));

  /* Test Data Bus. */
  ret_code = MemTestDataBus(memory_base);

  if (ret_code)
 2000304:	28000a26 	beq	r5,zero,2000330 <main+0x228>
 2000308:	00000606 	br	2000324 <main+0x21c>
{
  volatile unsigned int pattern;
  unsigned int ret_code = 0x0;

  /* Perform a walking 1's test at the given address. */
  for (pattern = 1; pattern != 0; pattern <<= 1)
 200030c:	d8800317 	ldw	r2,12(sp)
 2000310:	1085883a 	add	r2,r2,r2
 2000314:	d8800315 	stw	r2,12(sp)
 2000318:	d8800317 	ldw	r2,12(sp)
 200031c:	103ff31e 	bne	r2,zero,20002ec <__alt_data_end+0xfe0002ec>
 2000320:	00000306 	br	2000330 <main+0x228>

  /* Test Data Bus. */
  ret_code = MemTestDataBus(memory_base);

  if (ret_code)
   printf(" -Data bus test failed at bit 0x%X", (int)ret_code);
 2000324:	01008034 	movhi	r4,512
 2000328:	2106cc04 	addi	r4,r4,6960
 200032c:	0000b706 	br	200060c <main+0x504>
  else
    printf(" -Data bus test passed\n");
 2000330:	01008034 	movhi	r4,512
 2000334:	2106d504 	addi	r4,r4,6996
 2000338:	200087c0 	call	200087c <puts>
  int ret_code = 0x0;
  int y, ret_code2=0;

  /* Find out what range of memory we are testing */
  MemGetAddressRange(&memory_base, &memory_end);
  memory_size = (memory_end - memory_base);
 200033c:	9c27c83a 	sub	r19,r19,r16
*           stuck-at's, shorts, or open circuits.
*
******************************************************************/
static int MemTestAddressBus(unsigned int memory_base, unsigned int nBytes)
{
  unsigned int address_mask = (nBytes - 1);
 2000340:	993fffc4 	addi	r4,r19,-1
  unsigned int antipattern  = 0x55555555;

  unsigned int ret_code = 0x0;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 2000344:	00800104 	movi	r2,4
 2000348:	00000306 	br	2000358 <main+0x250>
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
 200034c:	1407883a 	add	r3,r2,r16
 2000350:	1d400035 	stwio	r21,0(r3)
  unsigned int antipattern  = 0x55555555;

  unsigned int ret_code = 0x0;

  /* Write the default pattern at each of the power-of-two offsets. */
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 2000354:	1085883a 	add	r2,r2,r2
 2000358:	1106703a 	and	r3,r2,r4
 200035c:	183ffb1e 	bne	r3,zero,200034c <__alt_data_end+0xfe00034c>
    IOWR_32DIRECT(memory_base, offset, pattern);
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
 2000360:	85800035 	stwio	r22,0(r16)
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 2000364:	00800104 	movi	r2,4
 2000368:	00000406 	br	200037c <main+0x274>
  {
     if (IORD_32DIRECT(memory_base, offset) != pattern)
 200036c:	140b883a 	add	r5,r2,r16
 2000370:	28c00037 	ldwio	r3,0(r5)
 2000374:	1c80041e 	bne	r3,r18,2000388 <main+0x280>
  }

  /* Check for address bits stuck high. */
  test_offset = 0;
  IOWR_32DIRECT(memory_base, test_offset, antipattern);
  for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 2000378:	1085883a 	add	r2,r2,r2
 200037c:	1106703a 	and	r3,r2,r4
 2000380:	183ffa1e 	bne	r3,zero,200036c <__alt_data_end+0xfe00036c>
  unsigned int test_offset;

  unsigned int pattern     = 0xAAAAAAAA;
  unsigned int antipattern  = 0x55555555;

  unsigned int ret_code = 0x0;
 2000384:	000b883a 	mov	r5,zero
        break;
     }
  }

  /* Check for address bits stuck low or shorted. */
  IOWR_32DIRECT(memory_base, test_offset, pattern);
 2000388:	84800035 	stwio	r18,0(r16)
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
 200038c:	00800104 	movi	r2,4
 2000390:	00001006 	br	20003d4 <main+0x2cc>
  {
    if (!ret_code)
 2000394:	28000e1e 	bne	r5,zero,20003d0 <main+0x2c8>
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
 2000398:	140d883a 	add	r6,r2,r16
 200039c:	35c00035 	stwio	r23,0(r6)
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 20003a0:	00c00104 	movi	r3,4
 20003a4:	00000506 	br	20003bc <main+0x2b4>
      {
        if ((IORD_32DIRECT(memory_base, offset) != pattern) && (offset != test_offset))
 20003a8:	1c0f883a 	add	r7,r3,r16
 20003ac:	39c00037 	ldwio	r7,0(r7)
 20003b0:	3c800126 	beq	r7,r18,20003b8 <main+0x2b0>
 20003b4:	1880041e 	bne	r3,r2,20003c8 <main+0x2c0>
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
  {
    if (!ret_code)
    {
      IOWR_32DIRECT(memory_base, test_offset, antipattern);
      for (offset = sizeof(unsigned int); (offset & address_mask) != 0; offset <<= 1)
 20003b8:	18c7883a 	add	r3,r3,r3
 20003bc:	190e703a 	and	r7,r3,r4
 20003c0:	383ff91e 	bne	r7,zero,20003a8 <__alt_data_end+0xfe0003a8>
 20003c4:	00000106 	br	20003cc <main+0x2c4>
      {
        if ((IORD_32DIRECT(memory_base, offset) != pattern) && (offset != test_offset))
        {
          ret_code = (memory_base + test_offset);
 20003c8:	300b883a 	mov	r5,r6
          break;
        }
      }
      IOWR_32DIRECT(memory_base, test_offset, pattern);
 20003cc:	34800035 	stwio	r18,0(r6)
     }
  }

  /* Check for address bits stuck low or shorted. */
  IOWR_32DIRECT(memory_base, test_offset, pattern);
  for (test_offset = sizeof(unsigned int); (test_offset & address_mask) != 0; test_offset <<= 1)
 20003d0:	1085883a 	add	r2,r2,r2
 20003d4:	1106703a 	and	r3,r2,r4
 20003d8:	183fee1e 	bne	r3,zero,2000394 <__alt_data_end+0xfe000394>

  /* Test Address Bus. */
  if (!ret_code)
  {
    ret_code  = MemTestAddressBus(memory_base, memory_size);
    if  (ret_code)
 20003dc:	28000326 	beq	r5,zero,20003ec <main+0x2e4>
      printf(" -Address bus test failed at address 0x%X", (int)ret_code);
 20003e0:	01008034 	movhi	r4,512
 20003e4:	2106db04 	addi	r4,r4,7020
 20003e8:	00008806 	br	200060c <main+0x504>
    else
      printf(" -Address bus test passed\n");
 20003ec:	01008034 	movhi	r4,512
 20003f0:	2106e604 	addi	r4,r4,7064
 20003f4:	200087c0 	call	200087c <puts>
static int MemTest8_16BitAccess(unsigned int memory_base)
{
  int ret_code = 0x0;

  /* Write 4 bytes */
  IOWR_8DIRECT(memory_base, 0, 0x0A);
 20003f8:	00800284 	movi	r2,10
 20003fc:	80800025 	stbio	r2,0(r16)
  IOWR_8DIRECT(memory_base, 1, 0x05);
 2000400:	80c00044 	addi	r3,r16,1
 2000404:	00800144 	movi	r2,5
 2000408:	18800025 	stbio	r2,0(r3)
  IOWR_8DIRECT(memory_base, 2, 0xA0);
 200040c:	80800084 	addi	r2,r16,2
 2000410:	013fe804 	movi	r4,-96
 2000414:	11000025 	stbio	r4,0(r2)
  IOWR_8DIRECT(memory_base, 3, 0x50);
 2000418:	810000c4 	addi	r4,r16,3
 200041c:	01401404 	movi	r5,80
 2000420:	21400025 	stbio	r5,0(r4)

  /* Read it back as one word */
  if(IORD_32DIRECT(memory_base, 0) != 0x50A0050A)
 2000424:	81800037 	ldwio	r6,0(r16)
 2000428:	01542834 	movhi	r5,20640
 200042c:	29414284 	addi	r5,r5,1290
 2000430:	31400126 	beq	r6,r5,2000438 <main+0x330>
  {
    ret_code = memory_base;
  }

  /* Read it back as two half-words */
  if (!ret_code)
 2000434:	8000401e 	bne	r16,zero,2000538 <main+0x430>
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x50A0) ||
 2000438:	1180002b 	ldhuio	r6,0(r2)
 200043c:	01542804 	movi	r5,20640
 2000440:	31bfffcc 	andi	r6,r6,65535
 2000444:	31400226 	beq	r6,r5,2000450 <main+0x348>
      ret_code = memory_base;
    }
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
 2000448:	80000526 	beq	r16,zero,2000460 <main+0x358>
 200044c:	00003a06 	br	2000538 <main+0x430>

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x50A0) ||
        (IORD_16DIRECT(memory_base, 0) != 0x050A))
 2000450:	8180002b 	ldhuio	r6,0(r16)
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x50A0) ||
 2000454:	01414284 	movi	r5,1290
        (IORD_16DIRECT(memory_base, 0) != 0x050A))
 2000458:	31bfffcc 	andi	r6,r6,65535
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x50A0) ||
 200045c:	317ffa1e 	bne	r6,r5,2000448 <__alt_data_end+0xfe000448>
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 2000460:	21800023 	ldbuio	r6,0(r4)
 2000464:	01401404 	movi	r5,80
 2000468:	31803fcc 	andi	r6,r6,255
 200046c:	31400226 	beq	r6,r5,2000478 <main+0x370>
    ret_code = memory_base;
    }
  }

  /* Write 2 half-words */
  if (!ret_code)
 2000470:	80000d26 	beq	r16,zero,20004a8 <main+0x3a0>
 2000474:	00003006 	br	2000538 <main+0x430>

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 2000478:	11800023 	ldbuio	r6,0(r2)
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 200047c:	01402804 	movi	r5,160
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 2000480:	31803fcc 	andi	r6,r6,255
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
 2000484:	317ffa1e 	bne	r6,r5,2000470 <__alt_data_end+0xfe000470>
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
 2000488:	19800023 	ldbuio	r6,0(r3)

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 200048c:	01400144 	movi	r5,5
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
 2000490:	31803fcc 	andi	r6,r6,255

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
 2000494:	317ff61e 	bne	r6,r5,2000470 <__alt_data_end+0xfe000470>
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
        (IORD_8DIRECT(memory_base, 0) != 0x0A))
 2000498:	81800023 	ldbuio	r6,0(r16)
  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
 200049c:	01400284 	movi	r5,10
        (IORD_8DIRECT(memory_base, 0) != 0x0A))
 20004a0:	31803fcc 	andi	r6,r6,255
  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x50) ||
        (IORD_8DIRECT(memory_base, 2) != 0xA0) ||
        (IORD_8DIRECT(memory_base, 1) != 0x05) ||
 20004a4:	317ff21e 	bne	r6,r5,2000470 <__alt_data_end+0xfe000470>
  }

  /* Write 2 half-words */
  if (!ret_code)
  {
    IOWR_16DIRECT(memory_base, 0, 0x50A0);
 20004a8:	01542804 	movi	r5,20640
 20004ac:	8140002d 	sthio	r5,0(r16)
    IOWR_16DIRECT(memory_base, 2, 0x050A);
 20004b0:	01414284 	movi	r5,1290
 20004b4:	1140002d 	sthio	r5,0(r2)

    /* Read it back as one word */
    if(IORD_32DIRECT(memory_base, 0) != 0x050A50A0)
 20004b8:	81800037 	ldwio	r6,0(r16)
 20004bc:	014142b4 	movhi	r5,1290
 20004c0:	29542804 	addi	r5,r5,20640
 20004c4:	31400126 	beq	r6,r5,20004cc <main+0x3c4>
      ret_code = memory_base;
    }
  }

  /* Read it back as two half-words */
  if (!ret_code)
 20004c8:	80001b1e 	bne	r16,zero,2000538 <main+0x430>
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
 20004cc:	1180002b 	ldhuio	r6,0(r2)
 20004d0:	01414284 	movi	r5,1290
 20004d4:	31bfffcc 	andi	r6,r6,65535
 20004d8:	31400226 	beq	r6,r5,20004e4 <main+0x3dc>
      ret_code = memory_base;
    }
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
 20004dc:	80000526 	beq	r16,zero,20004f4 <main+0x3ec>
 20004e0:	00001506 	br	2000538 <main+0x430>

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
        (IORD_16DIRECT(memory_base, 0) != 0x50A0))
 20004e4:	8180002b 	ldhuio	r6,0(r16)
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
 20004e8:	01542804 	movi	r5,20640
        (IORD_16DIRECT(memory_base, 0) != 0x50A0))
 20004ec:	31bfffcc 	andi	r6,r6,65535
  }

  /* Read it back as two half-words */
  if (!ret_code)
  {
    if ((IORD_16DIRECT(memory_base, 2) != 0x050A) ||
 20004f0:	317ffa1e 	bne	r6,r5,20004dc <__alt_data_end+0xfe0004dc>
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 20004f4:	21400023 	ldbuio	r5,0(r4)
 20004f8:	01000144 	movi	r4,5
 20004fc:	29403fcc 	andi	r5,r5,255
 2000500:	29000c1e 	bne	r5,r4,2000534 <main+0x42c>
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 2000504:	11000023 	ldbuio	r4,0(r2)
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 2000508:	00800284 	movi	r2,10
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 200050c:	21003fcc 	andi	r4,r4,255
  }

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
 2000510:	2080081e 	bne	r4,r2,2000534 <main+0x42c>
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
 2000514:	18c00023 	ldbuio	r3,0(r3)

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 2000518:	00801404 	movi	r2,80
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
 200051c:	18c03fcc 	andi	r3,r3,255

  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
 2000520:	1880041e 	bne	r3,r2,2000534 <main+0x42c>
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
        (IORD_8DIRECT(memory_base, 0) != 0xA0))
 2000524:	80c00023 	ldbuio	r3,0(r16)
  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
 2000528:	00802804 	movi	r2,160
        (IORD_8DIRECT(memory_base, 0) != 0xA0))
 200052c:	18c03fcc 	andi	r3,r3,255
  /* Read it back as 4 bytes */
  if (!ret_code)
  {
    if ((IORD_8DIRECT(memory_base, 3) != 0x05) ||
        (IORD_8DIRECT(memory_base, 2) != 0x0A) ||
        (IORD_8DIRECT(memory_base, 1) != 0x50) ||
 2000530:	18800526 	beq	r3,r2,2000548 <main+0x440>

  /* Test byte and half-word access. */
  if (!ret_code)
  {
    ret_code = MemTest8_16BitAccess(memory_base);
    if  (ret_code)
 2000534:	80000426 	beq	r16,zero,2000548 <main+0x440>
      printf(" -Byte and half-word access test failed at address 0x%X", (int)ret_code);
 2000538:	01008034 	movhi	r4,512
 200053c:	2106ed04 	addi	r4,r4,7092
 2000540:	800b883a 	mov	r5,r16
 2000544:	00003106 	br	200060c <main+0x504>
    else
      printf(" -Byte and half-word access test passed\n");
 2000548:	01008034 	movhi	r4,512
 200054c:	2106fb04 	addi	r4,r4,7148
 2000550:	200087c0 	call	200087c <puts>
  }

  /* Test that each bit in the device can store both 1 and 0. */
  if (!ret_code)
  {
    printf(" -Testing each bit in memory device.");
 2000554:	01008034 	movhi	r4,512
 2000558:	21070504 	addi	r4,r4,7188
 200055c:	20006d00 	call	20006d0 <printf>
 2000560:	8005883a 	mov	r2,r16
  unsigned int pattern;
  unsigned int antipattern;
  unsigned int ret_code = 0x0;

  /* Fill memory with a known pattern. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 2000564:	00c00044 	movi	r3,1
 2000568:	00000306 	br	2000578 <main+0x470>
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
 200056c:	10c00035 	stwio	r3,0(r2)
  unsigned int pattern;
  unsigned int antipattern;
  unsigned int ret_code = 0x0;

  /* Fill memory with a known pattern. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 2000570:	18c00044 	addi	r3,r3,1
 2000574:	10800104 	addi	r2,r2,4
 2000578:	1409c83a 	sub	r4,r2,r16
 200057c:	24fffb36 	bltu	r4,r19,200056c <__alt_data_end+0xfe00056c>
  {
    IOWR_32DIRECT(memory_base, offset, pattern);
  }

  printf(" .");
 2000580:	01008034 	movhi	r4,512
 2000584:	21070f04 	addi	r4,r4,7228
 2000588:	20006d00 	call	20006d0 <printf>
 200058c:	8023883a 	mov	r17,r16

  /* Check each location and invert it for the second pass. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 2000590:	00800044 	movi	r2,1
 2000594:	00000706 	br	20005b4 <main+0x4ac>
  {
    if (IORD_32DIRECT(memory_base, offset) != pattern)
 2000598:	89000037 	ldwio	r4,0(r17)
 200059c:	88c00104 	addi	r3,r17,4
 20005a0:	2080071e 	bne	r4,r2,20005c0 <main+0x4b8>
    {
      ret_code = (memory_base + offset);
      break;
    }
    antipattern = ~pattern;
 20005a4:	0088303a 	nor	r4,zero,r2
    IOWR_32DIRECT(memory_base, offset, antipattern);
 20005a8:	89000035 	stwio	r4,0(r17)
  }

  printf(" .");

  /* Check each location and invert it for the second pass. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 20005ac:	10800044 	addi	r2,r2,1
 20005b0:	1823883a 	mov	r17,r3
 20005b4:	8c07c83a 	sub	r3,r17,r16
 20005b8:	1cfff736 	bltu	r3,r19,2000598 <__alt_data_end+0xfe000598>
static int MemTestDevice(unsigned int memory_base, unsigned int nBytes)
{
  unsigned int offset;
  unsigned int pattern;
  unsigned int antipattern;
  unsigned int ret_code = 0x0;
 20005bc:	0023883a 	mov	r17,zero
    }
    antipattern = ~pattern;
    IOWR_32DIRECT(memory_base, offset, antipattern);
  }

  printf(" .");
 20005c0:	01008034 	movhi	r4,512
 20005c4:	21070f04 	addi	r4,r4,7228
 20005c8:	20006d00 	call	20006d0 <printf>
 20005cc:	800b883a 	mov	r5,r16
 20005d0:	00bfff84 	movi	r2,-2
 20005d4:	00000706 	br	20005f4 <main+0x4ec>

  /* Check each location for the inverted pattern and zero it. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
  {
    antipattern = ~pattern;
    if (IORD_32DIRECT(memory_base, offset) != antipattern)
 20005d8:	29800037 	ldwio	r6,0(r5)
 20005dc:	28c00104 	addi	r3,r5,4
 20005e0:	113fffc4 	addi	r4,r2,-1
 20005e4:	3080061e 	bne	r6,r2,2000600 <main+0x4f8>
    {
      ret_code = (memory_base + offset);
      break;
    }
    IOWR_32DIRECT(memory_base, offset, 0x0);
 20005e8:	28000035 	stwio	zero,0(r5)
 20005ec:	2005883a 	mov	r2,r4
 20005f0:	180b883a 	mov	r5,r3
  }

  printf(" .");

  /* Check each location for the inverted pattern and zero it. */
  for (pattern = 1, offset = 0; offset < nBytes; pattern++, offset+=4)
 20005f4:	2c07c83a 	sub	r3,r5,r16
 20005f8:	1cfff736 	bltu	r3,r19,20005d8 <__alt_data_end+0xfe0005d8>
 20005fc:	880b883a 	mov	r5,r17
  /* Test that each bit in the device can store both 1 and 0. */
  if (!ret_code)
  {
    printf(" -Testing each bit in memory device.");
    ret_code = MemTestDevice(memory_base, memory_size);
    if  (ret_code)
 2000600:	28000426 	beq	r5,zero,2000614 <main+0x50c>
      printf("  failed at address 0x%X", (int)ret_code);
 2000604:	01008034 	movhi	r4,512
 2000608:	21071004 	addi	r4,r4,7232
 200060c:	20006d00 	call	20006d0 <printf>
 2000610:	00000f06 	br	2000650 <main+0x548>
    else
      printf("  passed\n");
 2000614:	01008034 	movhi	r4,512
 2000618:	21071704 	addi	r4,r4,7260
 200061c:	200087c0 	call	200087c <puts>
  }
      
  if (!ret_code)
    printf("Memory at 0x%X Okay\n", memory_base);
 2000620:	800b883a 	mov	r5,r16
 2000624:	01008034 	movhi	r4,512
 2000628:	21071a04 	addi	r4,r4,7272
 200062c:	20006d00 	call	20006d0 <printf>
  if (ret_code)
	  ret_code2++;
//}
if(!ret_code2)
	printf(" Pocket test OK\n");
 2000630:	01008034 	movhi	r4,512
 2000634:	21072004 	addi	r4,r4,7296
 2000638:	200087c0 	call	200087c <puts>
static void TestRam(void)
{
  
  int memory_base, memory_end, memory_size;
  int ret_code = 0x0;
  int y, ret_code2=0;
 200063c:	000b883a 	mov	r5,zero
  if (ret_code)
	  ret_code2++;
//}
if(!ret_code2)
	printf(" Pocket test OK\n");
	printf("%d failed tests\n", ret_code2);
 2000640:	01008034 	movhi	r4,512
 2000644:	21072404 	addi	r4,r4,7312
 2000648:	20006d00 	call	20006d0 <printf>
 200064c:	003ed506 	br	20001a4 <__alt_data_end+0xfe0001a4>
  }
      
  if (!ret_code)
    printf("Memory at 0x%X Okay\n", memory_base);
  if (ret_code)
	  ret_code2++;
 2000650:	01400044 	movi	r5,1
 2000654:	003ffa06 	br	2000640 <__alt_data_end+0xfe000640>
    printf("\nPress enter to continue or 'q' to quit.\n");
    ch = alt_getchar();
    putchar(ch);
    if(ch == 'q' || ch == 'Q')
    {
        printf( "\nExiting from Memory Test.\n");
 2000658:	01008034 	movhi	r4,512
 200065c:	21067104 	addi	r4,r4,6596
 2000660:	200087c0 	call	200087c <puts>
    {
        TestRam();
    }
  }
  return (0);
}
 2000664:	0005883a 	mov	r2,zero
 2000668:	dfc00d17 	ldw	ra,52(sp)
 200066c:	ddc00c17 	ldw	r23,48(sp)
 2000670:	dd800b17 	ldw	r22,44(sp)
 2000674:	dd400a17 	ldw	r21,40(sp)
 2000678:	dd000917 	ldw	r20,36(sp)
 200067c:	dcc00817 	ldw	r19,32(sp)
 2000680:	dc800717 	ldw	r18,28(sp)
 2000684:	dc400617 	ldw	r17,24(sp)
 2000688:	dc000517 	ldw	r16,20(sp)
 200068c:	dec00e04 	addi	sp,sp,56
 2000690:	f800283a 	ret

02000694 <_printf_r>:
 2000694:	defffd04 	addi	sp,sp,-12
 2000698:	dfc00015 	stw	ra,0(sp)
 200069c:	d9800115 	stw	r6,4(sp)
 20006a0:	d9c00215 	stw	r7,8(sp)
 20006a4:	20800217 	ldw	r2,8(r4)
 20006a8:	00c08034 	movhi	r3,512
 20006ac:	18c48604 	addi	r3,r3,4632
 20006b0:	280d883a 	mov	r6,r5
 20006b4:	10c00115 	stw	r3,4(r2)
 20006b8:	100b883a 	mov	r5,r2
 20006bc:	d9c00104 	addi	r7,sp,4
 20006c0:	2000b300 	call	2000b30 <___vfprintf_internal_r>
 20006c4:	dfc00017 	ldw	ra,0(sp)
 20006c8:	dec00304 	addi	sp,sp,12
 20006cc:	f800283a 	ret

020006d0 <printf>:
 20006d0:	defffc04 	addi	sp,sp,-16
 20006d4:	dfc00015 	stw	ra,0(sp)
 20006d8:	d9400115 	stw	r5,4(sp)
 20006dc:	d9800215 	stw	r6,8(sp)
 20006e0:	d9c00315 	stw	r7,12(sp)
 20006e4:	00808034 	movhi	r2,512
 20006e8:	10883b04 	addi	r2,r2,8428
 20006ec:	10800017 	ldw	r2,0(r2)
 20006f0:	00c08034 	movhi	r3,512
 20006f4:	18c48604 	addi	r3,r3,4632
 20006f8:	200b883a 	mov	r5,r4
 20006fc:	10800217 	ldw	r2,8(r2)
 2000700:	d9800104 	addi	r6,sp,4
 2000704:	10c00115 	stw	r3,4(r2)
 2000708:	1009883a 	mov	r4,r2
 200070c:	20011f40 	call	20011f4 <__vfprintf_internal>
 2000710:	dfc00017 	ldw	ra,0(sp)
 2000714:	dec00404 	addi	sp,sp,16
 2000718:	f800283a 	ret

0200071c <putc>:
 200071c:	defffd04 	addi	sp,sp,-12
 2000720:	00808034 	movhi	r2,512
 2000724:	10883b04 	addi	r2,r2,8428
 2000728:	dc000115 	stw	r16,4(sp)
 200072c:	2021883a 	mov	r16,r4
 2000730:	11000017 	ldw	r4,0(r2)
 2000734:	dfc00215 	stw	ra,8(sp)
 2000738:	00808034 	movhi	r2,512
 200073c:	10848604 	addi	r2,r2,4632
 2000740:	28800115 	stw	r2,4(r5)
 2000744:	d80d883a 	mov	r6,sp
 2000748:	01c00044 	movi	r7,1
 200074c:	dc000005 	stb	r16,0(sp)
 2000750:	103ee83a 	callr	r2
 2000754:	00ffffc4 	movi	r3,-1
 2000758:	10c00526 	beq	r2,r3,2000770 <putc+0x54>
 200075c:	8005883a 	mov	r2,r16
 2000760:	dfc00217 	ldw	ra,8(sp)
 2000764:	dc000117 	ldw	r16,4(sp)
 2000768:	dec00304 	addi	sp,sp,12
 200076c:	f800283a 	ret
 2000770:	1021883a 	mov	r16,r2
 2000774:	003ff906 	br	200075c <__alt_data_end+0xfe00075c>

02000778 <_putc_r>:
 2000778:	00808034 	movhi	r2,512
 200077c:	10883b04 	addi	r2,r2,8428
 2000780:	defffd04 	addi	sp,sp,-12
 2000784:	11000017 	ldw	r4,0(r2)
 2000788:	dc000115 	stw	r16,4(sp)
 200078c:	dfc00215 	stw	ra,8(sp)
 2000790:	00808034 	movhi	r2,512
 2000794:	10848604 	addi	r2,r2,4632
 2000798:	2821883a 	mov	r16,r5
 200079c:	30800115 	stw	r2,4(r6)
 20007a0:	300b883a 	mov	r5,r6
 20007a4:	01c00044 	movi	r7,1
 20007a8:	d80d883a 	mov	r6,sp
 20007ac:	dc000005 	stb	r16,0(sp)
 20007b0:	103ee83a 	callr	r2
 20007b4:	00ffffc4 	movi	r3,-1
 20007b8:	10c00526 	beq	r2,r3,20007d0 <_putc_r+0x58>
 20007bc:	8005883a 	mov	r2,r16
 20007c0:	dfc00217 	ldw	ra,8(sp)
 20007c4:	dc000117 	ldw	r16,4(sp)
 20007c8:	dec00304 	addi	sp,sp,12
 20007cc:	f800283a 	ret
 20007d0:	1021883a 	mov	r16,r2
 20007d4:	003ff906 	br	20007bc <__alt_data_end+0xfe0007bc>

020007d8 <_putchar_r>:
 20007d8:	21800217 	ldw	r6,8(r4)
 20007dc:	20007781 	jmpi	2000778 <_putc_r>

020007e0 <putchar>:
 20007e0:	00808034 	movhi	r2,512
 20007e4:	10883b04 	addi	r2,r2,8428
 20007e8:	10800017 	ldw	r2,0(r2)
 20007ec:	200b883a 	mov	r5,r4
 20007f0:	11800217 	ldw	r6,8(r2)
 20007f4:	1009883a 	mov	r4,r2
 20007f8:	20007781 	jmpi	2000778 <_putc_r>

020007fc <_puts_r>:
 20007fc:	defffd04 	addi	sp,sp,-12
 2000800:	dc000015 	stw	r16,0(sp)
 2000804:	2021883a 	mov	r16,r4
 2000808:	2809883a 	mov	r4,r5
 200080c:	dfc00215 	stw	ra,8(sp)
 2000810:	dc400115 	stw	r17,4(sp)
 2000814:	2823883a 	mov	r17,r5
 2000818:	20008900 	call	2000890 <strlen>
 200081c:	81400217 	ldw	r5,8(r16)
 2000820:	00c08034 	movhi	r3,512
 2000824:	18c48604 	addi	r3,r3,4632
 2000828:	880d883a 	mov	r6,r17
 200082c:	8009883a 	mov	r4,r16
 2000830:	28c00115 	stw	r3,4(r5)
 2000834:	100f883a 	mov	r7,r2
 2000838:	183ee83a 	callr	r3
 200083c:	047fffc4 	movi	r17,-1
 2000840:	14400926 	beq	r2,r17,2000868 <_puts_r+0x6c>
 2000844:	81400217 	ldw	r5,8(r16)
 2000848:	8009883a 	mov	r4,r16
 200084c:	01808034 	movhi	r6,512
 2000850:	31860e04 	addi	r6,r6,6200
 2000854:	28800117 	ldw	r2,4(r5)
 2000858:	01c00044 	movi	r7,1
 200085c:	103ee83a 	callr	r2
 2000860:	14400126 	beq	r2,r17,2000868 <_puts_r+0x6c>
 2000864:	0005883a 	mov	r2,zero
 2000868:	dfc00217 	ldw	ra,8(sp)
 200086c:	dc400117 	ldw	r17,4(sp)
 2000870:	dc000017 	ldw	r16,0(sp)
 2000874:	dec00304 	addi	sp,sp,12
 2000878:	f800283a 	ret

0200087c <puts>:
 200087c:	00808034 	movhi	r2,512
 2000880:	10883b04 	addi	r2,r2,8428
 2000884:	200b883a 	mov	r5,r4
 2000888:	11000017 	ldw	r4,0(r2)
 200088c:	20007fc1 	jmpi	20007fc <_puts_r>

02000890 <strlen>:
 2000890:	20800007 	ldb	r2,0(r4)
 2000894:	10000626 	beq	r2,zero,20008b0 <strlen+0x20>
 2000898:	2005883a 	mov	r2,r4
 200089c:	10800044 	addi	r2,r2,1
 20008a0:	10c00007 	ldb	r3,0(r2)
 20008a4:	183ffd1e 	bne	r3,zero,200089c <__alt_data_end+0xfe00089c>
 20008a8:	1105c83a 	sub	r2,r2,r4
 20008ac:	f800283a 	ret
 20008b0:	0005883a 	mov	r2,zero
 20008b4:	f800283a 	ret

020008b8 <_strtol_r>:
 20008b8:	defff404 	addi	sp,sp,-48
 20008bc:	00808034 	movhi	r2,512
 20008c0:	10883c04 	addi	r2,r2,8432
 20008c4:	dcc00515 	stw	r19,20(sp)
 20008c8:	14c00017 	ldw	r19,0(r2)
 20008cc:	ddc00915 	stw	r23,36(sp)
 20008d0:	dd800815 	stw	r22,32(sp)
 20008d4:	dd000615 	stw	r20,24(sp)
 20008d8:	dc000215 	stw	r16,8(sp)
 20008dc:	dfc00b15 	stw	ra,44(sp)
 20008e0:	df000a15 	stw	fp,40(sp)
 20008e4:	dd400715 	stw	r21,28(sp)
 20008e8:	dc800415 	stw	r18,16(sp)
 20008ec:	dc400315 	stw	r17,12(sp)
 20008f0:	282d883a 	mov	r22,r5
 20008f4:	d9000015 	stw	r4,0(sp)
 20008f8:	302f883a 	mov	r23,r6
 20008fc:	3829883a 	mov	r20,r7
 2000900:	2821883a 	mov	r16,r5
 2000904:	84400007 	ldb	r17,0(r16)
 2000908:	84000044 	addi	r16,r16,1
 200090c:	9c45883a 	add	r2,r19,r17
 2000910:	10800003 	ldbu	r2,0(r2)
 2000914:	1080020c 	andi	r2,r2,8
 2000918:	10803fcc 	andi	r2,r2,255
 200091c:	1080201c 	xori	r2,r2,128
 2000920:	10bfe004 	addi	r2,r2,-128
 2000924:	103ff71e 	bne	r2,zero,2000904 <__alt_data_end+0xfe000904>
 2000928:	00800b44 	movi	r2,45
 200092c:	88806726 	beq	r17,r2,2000acc <_strtol_r+0x214>
 2000930:	00800ac4 	movi	r2,43
 2000934:	88806926 	beq	r17,r2,2000adc <_strtol_r+0x224>
 2000938:	0039883a 	mov	fp,zero
 200093c:	a000461e 	bne	r20,zero,2000a58 <_strtol_r+0x1a0>
 2000940:	00800c04 	movi	r2,48
 2000944:	88804826 	beq	r17,r2,2000a68 <_strtol_r+0x1b0>
 2000948:	05000284 	movi	r20,10
 200094c:	a02b883a 	mov	r21,r20
 2000950:	00a00034 	movhi	r2,32768
 2000954:	e025003a 	cmpeq	r18,fp,zero
 2000958:	14a5c83a 	sub	r18,r2,r18
 200095c:	9009883a 	mov	r4,r18
 2000960:	a80b883a 	mov	r5,r21
 2000964:	200148c0 	call	200148c <__umodsi3>
 2000968:	9009883a 	mov	r4,r18
 200096c:	a80b883a 	mov	r5,r21
 2000970:	d8800115 	stw	r2,4(sp)
 2000974:	20014840 	call	2001484 <__udivsi3>
 2000978:	9c47883a 	add	r3,r19,r17
 200097c:	18c00003 	ldbu	r3,0(r3)
 2000980:	100f883a 	mov	r7,r2
 2000984:	0013883a 	mov	r9,zero
 2000988:	1a00010c 	andi	r8,r3,4
 200098c:	42003fcc 	andi	r8,r8,255
 2000990:	4200201c 	xori	r8,r8,128
 2000994:	423fe004 	addi	r8,r8,-128
 2000998:	0009883a 	mov	r4,zero
 200099c:	02bfffc4 	movi	r10,-1
 20009a0:	d9800117 	ldw	r6,4(sp)
 20009a4:	40001126 	beq	r8,zero,20009ec <_strtol_r+0x134>
 20009a8:	8c7ff404 	addi	r17,r17,-48
 20009ac:	8d00160e 	bge	r17,r20,2000a08 <_strtol_r+0x150>
 20009b0:	4a800526 	beq	r9,r10,20009c8 <_strtol_r+0x110>
 20009b4:	39003736 	bltu	r7,r4,2000a94 <_strtol_r+0x1dc>
 20009b8:	21c03526 	beq	r4,r7,2000a90 <_strtol_r+0x1d8>
 20009bc:	2549383a 	mul	r4,r4,r21
 20009c0:	02400044 	movi	r9,1
 20009c4:	8909883a 	add	r4,r17,r4
 20009c8:	84400007 	ldb	r17,0(r16)
 20009cc:	84000044 	addi	r16,r16,1
 20009d0:	9c47883a 	add	r3,r19,r17
 20009d4:	18c00003 	ldbu	r3,0(r3)
 20009d8:	1a00010c 	andi	r8,r3,4
 20009dc:	42003fcc 	andi	r8,r8,255
 20009e0:	4200201c 	xori	r8,r8,128
 20009e4:	423fe004 	addi	r8,r8,-128
 20009e8:	403fef1e 	bne	r8,zero,20009a8 <__alt_data_end+0xfe0009a8>
 20009ec:	1a0000cc 	andi	r8,r3,3
 20009f0:	40000526 	beq	r8,zero,2000a08 <_strtol_r+0x150>
 20009f4:	18c0004c 	andi	r3,r3,1
 20009f8:	18002826 	beq	r3,zero,2000a9c <_strtol_r+0x1e4>
 20009fc:	00800dc4 	movi	r2,55
 2000a00:	88a3c83a 	sub	r17,r17,r2
 2000a04:	8d3fea16 	blt	r17,r20,20009b0 <__alt_data_end+0xfe0009b0>
 2000a08:	00bfffc4 	movi	r2,-1
 2000a0c:	48802626 	beq	r9,r2,2000aa8 <_strtol_r+0x1f0>
 2000a10:	e0000126 	beq	fp,zero,2000a18 <_strtol_r+0x160>
 2000a14:	0109c83a 	sub	r4,zero,r4
 2000a18:	2005883a 	mov	r2,r4
 2000a1c:	b8000226 	beq	r23,zero,2000a28 <_strtol_r+0x170>
 2000a20:	4800281e 	bne	r9,zero,2000ac4 <_strtol_r+0x20c>
 2000a24:	bd800015 	stw	r22,0(r23)
 2000a28:	dfc00b17 	ldw	ra,44(sp)
 2000a2c:	df000a17 	ldw	fp,40(sp)
 2000a30:	ddc00917 	ldw	r23,36(sp)
 2000a34:	dd800817 	ldw	r22,32(sp)
 2000a38:	dd400717 	ldw	r21,28(sp)
 2000a3c:	dd000617 	ldw	r20,24(sp)
 2000a40:	dcc00517 	ldw	r19,20(sp)
 2000a44:	dc800417 	ldw	r18,16(sp)
 2000a48:	dc400317 	ldw	r17,12(sp)
 2000a4c:	dc000217 	ldw	r16,8(sp)
 2000a50:	dec00c04 	addi	sp,sp,48
 2000a54:	f800283a 	ret
 2000a58:	00800404 	movi	r2,16
 2000a5c:	a0bfbb1e 	bne	r20,r2,200094c <__alt_data_end+0xfe00094c>
 2000a60:	00800c04 	movi	r2,48
 2000a64:	88bfb91e 	bne	r17,r2,200094c <__alt_data_end+0xfe00094c>
 2000a68:	80800007 	ldb	r2,0(r16)
 2000a6c:	00c01e04 	movi	r3,120
 2000a70:	10c01e26 	beq	r2,r3,2000aec <_strtol_r+0x234>
 2000a74:	00c01604 	movi	r3,88
 2000a78:	10c01c26 	beq	r2,r3,2000aec <_strtol_r+0x234>
 2000a7c:	a000201e 	bne	r20,zero,2000b00 <_strtol_r+0x248>
 2000a80:	05400204 	movi	r21,8
 2000a84:	04400c04 	movi	r17,48
 2000a88:	a829883a 	mov	r20,r21
 2000a8c:	003fb006 	br	2000950 <__alt_data_end+0xfe000950>
 2000a90:	347fca0e 	bge	r6,r17,20009bc <__alt_data_end+0xfe0009bc>
 2000a94:	027fffc4 	movi	r9,-1
 2000a98:	003fcb06 	br	20009c8 <__alt_data_end+0xfe0009c8>
 2000a9c:	008015c4 	movi	r2,87
 2000aa0:	88a3c83a 	sub	r17,r17,r2
 2000aa4:	003fd706 	br	2000a04 <__alt_data_end+0xfe000a04>
 2000aa8:	d9000017 	ldw	r4,0(sp)
 2000aac:	00c00884 	movi	r3,34
 2000ab0:	e005003a 	cmpeq	r2,fp,zero
 2000ab4:	20c00015 	stw	r3,0(r4)
 2000ab8:	00e00034 	movhi	r3,32768
 2000abc:	1885c83a 	sub	r2,r3,r2
 2000ac0:	b83fd926 	beq	r23,zero,2000a28 <__alt_data_end+0xfe000a28>
 2000ac4:	85bfffc4 	addi	r22,r16,-1
 2000ac8:	003fd606 	br	2000a24 <__alt_data_end+0xfe000a24>
 2000acc:	07000044 	movi	fp,1
 2000ad0:	84400007 	ldb	r17,0(r16)
 2000ad4:	8721883a 	add	r16,r16,fp
 2000ad8:	003f9806 	br	200093c <__alt_data_end+0xfe00093c>
 2000adc:	84400007 	ldb	r17,0(r16)
 2000ae0:	0039883a 	mov	fp,zero
 2000ae4:	84000044 	addi	r16,r16,1
 2000ae8:	003f9406 	br	200093c <__alt_data_end+0xfe00093c>
 2000aec:	05400404 	movi	r21,16
 2000af0:	84400047 	ldb	r17,1(r16)
 2000af4:	a829883a 	mov	r20,r21
 2000af8:	84000084 	addi	r16,r16,2
 2000afc:	003f9406 	br	2000950 <__alt_data_end+0xfe000950>
 2000b00:	a02b883a 	mov	r21,r20
 2000b04:	04400c04 	movi	r17,48
 2000b08:	003f9106 	br	2000950 <__alt_data_end+0xfe000950>

02000b0c <strtol>:
 2000b0c:	00808034 	movhi	r2,512
 2000b10:	10883b04 	addi	r2,r2,8428
 2000b14:	2007883a 	mov	r3,r4
 2000b18:	11000017 	ldw	r4,0(r2)
 2000b1c:	2805883a 	mov	r2,r5
 2000b20:	300f883a 	mov	r7,r6
 2000b24:	180b883a 	mov	r5,r3
 2000b28:	100d883a 	mov	r6,r2
 2000b2c:	20008b81 	jmpi	20008b8 <_strtol_r>

02000b30 <___vfprintf_internal_r>:
 2000b30:	deffe204 	addi	sp,sp,-120
 2000b34:	d8c00804 	addi	r3,sp,32
 2000b38:	df001c15 	stw	fp,112(sp)
 2000b3c:	ddc01b15 	stw	r23,108(sp)
 2000b40:	dd401915 	stw	r21,100(sp)
 2000b44:	dd001815 	stw	r20,96(sp)
 2000b48:	dcc01715 	stw	r19,92(sp)
 2000b4c:	dc801615 	stw	r18,88(sp)
 2000b50:	dc001415 	stw	r16,80(sp)
 2000b54:	dfc01d15 	stw	ra,116(sp)
 2000b58:	dd801a15 	stw	r22,104(sp)
 2000b5c:	dc401515 	stw	r17,84(sp)
 2000b60:	2039883a 	mov	fp,r4
 2000b64:	d9c00e15 	stw	r7,56(sp)
 2000b68:	3021883a 	mov	r16,r6
 2000b6c:	0025883a 	mov	r18,zero
 2000b70:	d8001315 	stw	zero,76(sp)
 2000b74:	d8000d15 	stw	zero,52(sp)
 2000b78:	0029883a 	mov	r20,zero
 2000b7c:	d8000b15 	stw	zero,44(sp)
 2000b80:	d8000c15 	stw	zero,48(sp)
 2000b84:	d8001115 	stw	zero,68(sp)
 2000b88:	d8001015 	stw	zero,64(sp)
 2000b8c:	002b883a 	mov	r21,zero
 2000b90:	04c00044 	movi	r19,1
 2000b94:	d8c00a15 	stw	r3,40(sp)
 2000b98:	282f883a 	mov	r23,r5
 2000b9c:	80c00003 	ldbu	r3,0(r16)
 2000ba0:	84000044 	addi	r16,r16,1
 2000ba4:	18803fcc 	andi	r2,r3,255
 2000ba8:	1080201c 	xori	r2,r2,128
 2000bac:	10bfe004 	addi	r2,r2,-128
 2000bb0:	10001426 	beq	r2,zero,2000c04 <___vfprintf_internal_r+0xd4>
 2000bb4:	acc02f26 	beq	r21,r19,2000c74 <___vfprintf_internal_r+0x144>
 2000bb8:	9d401f16 	blt	r19,r21,2000c38 <___vfprintf_internal_r+0x108>
 2000bbc:	a83ff71e 	bne	r21,zero,2000b9c <__alt_data_end+0xfe000b9c>
 2000bc0:	01000944 	movi	r4,37
 2000bc4:	1100d526 	beq	r2,r4,2000f1c <___vfprintf_internal_r+0x3ec>
 2000bc8:	b8800117 	ldw	r2,4(r23)
 2000bcc:	d8c00905 	stb	r3,36(sp)
 2000bd0:	e009883a 	mov	r4,fp
 2000bd4:	b80b883a 	mov	r5,r23
 2000bd8:	d9800904 	addi	r6,sp,36
 2000bdc:	01c00044 	movi	r7,1
 2000be0:	103ee83a 	callr	r2
 2000be4:	10009c1e 	bne	r2,zero,2000e58 <___vfprintf_internal_r+0x328>
 2000be8:	80c00003 	ldbu	r3,0(r16)
 2000bec:	94800044 	addi	r18,r18,1
 2000bf0:	84000044 	addi	r16,r16,1
 2000bf4:	18803fcc 	andi	r2,r3,255
 2000bf8:	1080201c 	xori	r2,r2,128
 2000bfc:	10bfe004 	addi	r2,r2,-128
 2000c00:	103fec1e 	bne	r2,zero,2000bb4 <__alt_data_end+0xfe000bb4>
 2000c04:	9005883a 	mov	r2,r18
 2000c08:	dfc01d17 	ldw	ra,116(sp)
 2000c0c:	df001c17 	ldw	fp,112(sp)
 2000c10:	ddc01b17 	ldw	r23,108(sp)
 2000c14:	dd801a17 	ldw	r22,104(sp)
 2000c18:	dd401917 	ldw	r21,100(sp)
 2000c1c:	dd001817 	ldw	r20,96(sp)
 2000c20:	dcc01717 	ldw	r19,92(sp)
 2000c24:	dc801617 	ldw	r18,88(sp)
 2000c28:	dc401517 	ldw	r17,84(sp)
 2000c2c:	dc001417 	ldw	r16,80(sp)
 2000c30:	dec01e04 	addi	sp,sp,120
 2000c34:	f800283a 	ret
 2000c38:	01000084 	movi	r4,2
 2000c3c:	a9001126 	beq	r21,r4,2000c84 <___vfprintf_internal_r+0x154>
 2000c40:	010000c4 	movi	r4,3
 2000c44:	a93fd51e 	bne	r21,r4,2000b9c <__alt_data_end+0xfe000b9c>
 2000c48:	193ff404 	addi	r4,r3,-48
 2000c4c:	21003fcc 	andi	r4,r4,255
 2000c50:	01400244 	movi	r5,9
 2000c54:	29001936 	bltu	r5,r4,2000cbc <___vfprintf_internal_r+0x18c>
 2000c58:	d8c00b17 	ldw	r3,44(sp)
 2000c5c:	00bfffc4 	movi	r2,-1
 2000c60:	1880e126 	beq	r3,r2,2000fe8 <___vfprintf_internal_r+0x4b8>
 2000c64:	188002a4 	muli	r2,r3,10
 2000c68:	2089883a 	add	r4,r4,r2
 2000c6c:	d9000b15 	stw	r4,44(sp)
 2000c70:	003fca06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2000c74:	01000c04 	movi	r4,48
 2000c78:	1100d626 	beq	r2,r4,2000fd4 <___vfprintf_internal_r+0x4a4>
 2000c7c:	01000944 	movi	r4,37
 2000c80:	1100f026 	beq	r2,r4,2001044 <___vfprintf_internal_r+0x514>
 2000c84:	193ff404 	addi	r4,r3,-48
 2000c88:	21003fcc 	andi	r4,r4,255
 2000c8c:	01400244 	movi	r5,9
 2000c90:	29000836 	bltu	r5,r4,2000cb4 <___vfprintf_internal_r+0x184>
 2000c94:	d8c00c17 	ldw	r3,48(sp)
 2000c98:	00bfffc4 	movi	r2,-1
 2000c9c:	1880d026 	beq	r3,r2,2000fe0 <___vfprintf_internal_r+0x4b0>
 2000ca0:	188002a4 	muli	r2,r3,10
 2000ca4:	2089883a 	add	r4,r4,r2
 2000ca8:	d9000c15 	stw	r4,48(sp)
 2000cac:	05400084 	movi	r21,2
 2000cb0:	003fba06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2000cb4:	01000b84 	movi	r4,46
 2000cb8:	1100a526 	beq	r2,r4,2000f50 <___vfprintf_internal_r+0x420>
 2000cbc:	01001b04 	movi	r4,108
 2000cc0:	1100a126 	beq	r2,r4,2000f48 <___vfprintf_internal_r+0x418>
 2000cc4:	d9400b17 	ldw	r5,44(sp)
 2000cc8:	00bfffc4 	movi	r2,-1
 2000ccc:	2880da26 	beq	r5,r2,2001038 <___vfprintf_internal_r+0x508>
 2000cd0:	d8001015 	stw	zero,64(sp)
 2000cd4:	18ffea04 	addi	r3,r3,-88
 2000cd8:	18c03fcc 	andi	r3,r3,255
 2000cdc:	00800804 	movi	r2,32
 2000ce0:	10c0022e 	bgeu	r2,r3,2000cec <___vfprintf_internal_r+0x1bc>
 2000ce4:	002b883a 	mov	r21,zero
 2000ce8:	003fac06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2000cec:	18c7883a 	add	r3,r3,r3
 2000cf0:	18c7883a 	add	r3,r3,r3
 2000cf4:	01008034 	movhi	r4,512
 2000cf8:	21034204 	addi	r4,r4,3336
 2000cfc:	1907883a 	add	r3,r3,r4
 2000d00:	18800017 	ldw	r2,0(r3)
 2000d04:	1000683a 	jmp	r2
 2000d08:	02001070 	cmpltui	r8,zero,65
 2000d0c:	02000ce4 	muli	r8,zero,51
 2000d10:	02000ce4 	muli	r8,zero,51
 2000d14:	02000ce4 	muli	r8,zero,51
 2000d18:	02000ce4 	muli	r8,zero,51
 2000d1c:	02000ce4 	muli	r8,zero,51
 2000d20:	02000ce4 	muli	r8,zero,51
 2000d24:	02000ce4 	muli	r8,zero,51
 2000d28:	02000ce4 	muli	r8,zero,51
 2000d2c:	02000ce4 	muli	r8,zero,51
 2000d30:	02000ce4 	muli	r8,zero,51
 2000d34:	02001080 	call	200108 <__alt_mem_sdram-0x1dffef8>
 2000d38:	02000d8c 	andi	r8,zero,54
 2000d3c:	02000ce4 	muli	r8,zero,51
 2000d40:	02000ce4 	muli	r8,zero,51
 2000d44:	02000ce4 	muli	r8,zero,51
 2000d48:	02000ce4 	muli	r8,zero,51
 2000d4c:	02000d8c 	andi	r8,zero,54
 2000d50:	02000ce4 	muli	r8,zero,51
 2000d54:	02000ce4 	muli	r8,zero,51
 2000d58:	02000ce4 	muli	r8,zero,51
 2000d5c:	02000ce4 	muli	r8,zero,51
 2000d60:	02000ce4 	muli	r8,zero,51
 2000d64:	02000e60 	cmpeqi	r8,zero,57
 2000d68:	02000ce4 	muli	r8,zero,51
 2000d6c:	02000ce4 	muli	r8,zero,51
 2000d70:	02000ce4 	muli	r8,zero,51
 2000d74:	020010c8 	cmpgei	r8,zero,67
 2000d78:	02000ce4 	muli	r8,zero,51
 2000d7c:	02000e64 	muli	r8,zero,57
 2000d80:	02000ce4 	muli	r8,zero,51
 2000d84:	02000ce4 	muli	r8,zero,51
 2000d88:	02001078 	rdprs	r8,zero,65
 2000d8c:	d8c00d17 	ldw	r3,52(sp)
 2000d90:	18003426 	beq	r3,zero,2000e64 <___vfprintf_internal_r+0x334>
 2000d94:	d9000e17 	ldw	r4,56(sp)
 2000d98:	00c00044 	movi	r3,1
 2000d9c:	25800017 	ldw	r22,0(r4)
 2000da0:	21000104 	addi	r4,r4,4
 2000da4:	d9000e15 	stw	r4,56(sp)
 2000da8:	d8c00d15 	stw	r3,52(sp)
 2000dac:	b0010b16 	blt	r22,zero,20011dc <___vfprintf_internal_r+0x6ac>
 2000db0:	d8001215 	stw	zero,72(sp)
 2000db4:	d82b883a 	mov	r21,sp
 2000db8:	b000321e 	bne	r22,zero,2000e84 <___vfprintf_internal_r+0x354>
 2000dbc:	d8c00b17 	ldw	r3,44(sp)
 2000dc0:	d809883a 	mov	r4,sp
 2000dc4:	00c00b0e 	bge	zero,r3,2000df4 <___vfprintf_internal_r+0x2c4>
 2000dc8:	d8800b17 	ldw	r2,44(sp)
 2000dcc:	d82b883a 	mov	r21,sp
 2000dd0:	00c00c04 	movi	r3,48
 2000dd4:	00000206 	br	2000de0 <___vfprintf_internal_r+0x2b0>
 2000dd8:	d9400a17 	ldw	r5,40(sp)
 2000ddc:	a9400426 	beq	r21,r5,2000df0 <___vfprintf_internal_r+0x2c0>
 2000de0:	a8c00005 	stb	r3,0(r21)
 2000de4:	10bfffc4 	addi	r2,r2,-1
 2000de8:	ad400044 	addi	r21,r21,1
 2000dec:	103ffa1e 	bne	r2,zero,2000dd8 <__alt_data_end+0xfe000dd8>
 2000df0:	a92dc83a 	sub	r22,r21,r4
 2000df4:	d8c01217 	ldw	r3,72(sp)
 2000df8:	b0c5883a 	add	r2,r22,r3
 2000dfc:	d8c00c17 	ldw	r3,48(sp)
 2000e00:	1885c83a 	sub	r2,r3,r2
 2000e04:	d8c01017 	ldw	r3,64(sp)
 2000e08:	d8800f15 	stw	r2,60(sp)
 2000e0c:	18007826 	beq	r3,zero,2000ff0 <___vfprintf_internal_r+0x4c0>
 2000e10:	d8c01217 	ldw	r3,72(sp)
 2000e14:	1800e41e 	bne	r3,zero,20011a8 <___vfprintf_internal_r+0x678>
 2000e18:	d8c00f17 	ldw	r3,60(sp)
 2000e1c:	00c05c0e 	bge	zero,r3,2000f90 <___vfprintf_internal_r+0x460>
 2000e20:	00800c04 	movi	r2,48
 2000e24:	d88008c5 	stb	r2,35(sp)
 2000e28:	1c7fffc4 	addi	r17,r3,-1
 2000e2c:	00000306 	br	2000e3c <___vfprintf_internal_r+0x30c>
 2000e30:	8c7fffc4 	addi	r17,r17,-1
 2000e34:	013fffc4 	movi	r4,-1
 2000e38:	8900eb26 	beq	r17,r4,20011e8 <___vfprintf_internal_r+0x6b8>
 2000e3c:	b8800117 	ldw	r2,4(r23)
 2000e40:	e009883a 	mov	r4,fp
 2000e44:	b80b883a 	mov	r5,r23
 2000e48:	d98008c4 	addi	r6,sp,35
 2000e4c:	01c00044 	movi	r7,1
 2000e50:	103ee83a 	callr	r2
 2000e54:	103ff626 	beq	r2,zero,2000e30 <__alt_data_end+0xfe000e30>
 2000e58:	04bfffc4 	movi	r18,-1
 2000e5c:	003f6906 	br	2000c04 <__alt_data_end+0xfe000c04>
 2000e60:	05000204 	movi	r20,8
 2000e64:	d9400e17 	ldw	r5,56(sp)
 2000e68:	2d800017 	ldw	r22,0(r5)
 2000e6c:	29400104 	addi	r5,r5,4
 2000e70:	d9400e15 	stw	r5,56(sp)
 2000e74:	d8000d15 	stw	zero,52(sp)
 2000e78:	d8001215 	stw	zero,72(sp)
 2000e7c:	d82b883a 	mov	r21,sp
 2000e80:	b03fce26 	beq	r22,zero,2000dbc <__alt_data_end+0xfe000dbc>
 2000e84:	9005883a 	mov	r2,r18
 2000e88:	dc000f15 	stw	r16,60(sp)
 2000e8c:	a025883a 	mov	r18,r20
 2000e90:	04400244 	movi	r17,9
 2000e94:	dc001317 	ldw	r16,76(sp)
 2000e98:	1029883a 	mov	r20,r2
 2000e9c:	00000506 	br	2000eb4 <___vfprintf_internal_r+0x384>
 2000ea0:	b5800c04 	addi	r22,r22,48
 2000ea4:	ad800005 	stb	r22,0(r21)
 2000ea8:	102d883a 	mov	r22,r2
 2000eac:	ad400044 	addi	r21,r21,1
 2000eb0:	10000c26 	beq	r2,zero,2000ee4 <___vfprintf_internal_r+0x3b4>
 2000eb4:	b009883a 	mov	r4,r22
 2000eb8:	900b883a 	mov	r5,r18
 2000ebc:	20014840 	call	2001484 <__udivsi3>
 2000ec0:	9089383a 	mul	r4,r18,r2
 2000ec4:	b12dc83a 	sub	r22,r22,r4
 2000ec8:	8dbff50e 	bge	r17,r22,2000ea0 <__alt_data_end+0xfe000ea0>
 2000ecc:	80001126 	beq	r16,zero,2000f14 <___vfprintf_internal_r+0x3e4>
 2000ed0:	b5800dc4 	addi	r22,r22,55
 2000ed4:	ad800005 	stb	r22,0(r21)
 2000ed8:	102d883a 	mov	r22,r2
 2000edc:	ad400044 	addi	r21,r21,1
 2000ee0:	103ff41e 	bne	r2,zero,2000eb4 <__alt_data_end+0xfe000eb4>
 2000ee4:	d8c00b17 	ldw	r3,44(sp)
 2000ee8:	a005883a 	mov	r2,r20
 2000eec:	aeedc83a 	sub	r22,r21,sp
 2000ef0:	9029883a 	mov	r20,r18
 2000ef4:	1025883a 	mov	r18,r2
 2000ef8:	1d85c83a 	sub	r2,r3,r22
 2000efc:	dc000f17 	ldw	r16,60(sp)
 2000f00:	d809883a 	mov	r4,sp
 2000f04:	00bfbb0e 	bge	zero,r2,2000df4 <__alt_data_end+0xfe000df4>
 2000f08:	d8c00a17 	ldw	r3,40(sp)
 2000f0c:	a8ffb036 	bltu	r21,r3,2000dd0 <__alt_data_end+0xfe000dd0>
 2000f10:	003fb806 	br	2000df4 <__alt_data_end+0xfe000df4>
 2000f14:	b58015c4 	addi	r22,r22,87
 2000f18:	003fe206 	br	2000ea4 <__alt_data_end+0xfe000ea4>
 2000f1c:	00c00044 	movi	r3,1
 2000f20:	d8c00d15 	stw	r3,52(sp)
 2000f24:	00ffffc4 	movi	r3,-1
 2000f28:	d8c00b15 	stw	r3,44(sp)
 2000f2c:	d8001315 	stw	zero,76(sp)
 2000f30:	05000284 	movi	r20,10
 2000f34:	d8c00c15 	stw	r3,48(sp)
 2000f38:	d8001115 	stw	zero,68(sp)
 2000f3c:	d8001015 	stw	zero,64(sp)
 2000f40:	dd400d17 	ldw	r21,52(sp)
 2000f44:	003f1506 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2000f48:	00c00044 	movi	r3,1
 2000f4c:	d8c01115 	stw	r3,68(sp)
 2000f50:	054000c4 	movi	r21,3
 2000f54:	003f1106 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2000f58:	d8c00f17 	ldw	r3,60(sp)
 2000f5c:	90e5883a 	add	r18,r18,r3
 2000f60:	d8c01217 	ldw	r3,72(sp)
 2000f64:	18000a26 	beq	r3,zero,2000f90 <___vfprintf_internal_r+0x460>
 2000f68:	b8800117 	ldw	r2,4(r23)
 2000f6c:	00c00b44 	movi	r3,45
 2000f70:	d8c00905 	stb	r3,36(sp)
 2000f74:	e009883a 	mov	r4,fp
 2000f78:	b80b883a 	mov	r5,r23
 2000f7c:	d9800904 	addi	r6,sp,36
 2000f80:	01c00044 	movi	r7,1
 2000f84:	103ee83a 	callr	r2
 2000f88:	103fb31e 	bne	r2,zero,2000e58 <__alt_data_end+0xfe000e58>
 2000f8c:	94800044 	addi	r18,r18,1
 2000f90:	ada3c83a 	sub	r17,r21,r22
 2000f94:	05800316 	blt	zero,r22,2000fa4 <___vfprintf_internal_r+0x474>
 2000f98:	003f5206 	br	2000ce4 <__alt_data_end+0xfe000ce4>
 2000f9c:	94800044 	addi	r18,r18,1
 2000fa0:	ac7f5026 	beq	r21,r17,2000ce4 <__alt_data_end+0xfe000ce4>
 2000fa4:	ad7fffc4 	addi	r21,r21,-1
 2000fa8:	a8c00003 	ldbu	r3,0(r21)
 2000fac:	b8800117 	ldw	r2,4(r23)
 2000fb0:	e009883a 	mov	r4,fp
 2000fb4:	d8c00905 	stb	r3,36(sp)
 2000fb8:	b80b883a 	mov	r5,r23
 2000fbc:	d9800904 	addi	r6,sp,36
 2000fc0:	01c00044 	movi	r7,1
 2000fc4:	103ee83a 	callr	r2
 2000fc8:	103ff426 	beq	r2,zero,2000f9c <__alt_data_end+0xfe000f9c>
 2000fcc:	04bfffc4 	movi	r18,-1
 2000fd0:	003f0c06 	br	2000c04 <__alt_data_end+0xfe000c04>
 2000fd4:	dd401015 	stw	r21,64(sp)
 2000fd8:	05400084 	movi	r21,2
 2000fdc:	003eef06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2000fe0:	0005883a 	mov	r2,zero
 2000fe4:	003f2f06 	br	2000ca4 <__alt_data_end+0xfe000ca4>
 2000fe8:	0005883a 	mov	r2,zero
 2000fec:	003f1e06 	br	2000c68 <__alt_data_end+0xfe000c68>
 2000ff0:	d8c00f17 	ldw	r3,60(sp)
 2000ff4:	00ffda0e 	bge	zero,r3,2000f60 <__alt_data_end+0xfe000f60>
 2000ff8:	00800804 	movi	r2,32
 2000ffc:	d8800885 	stb	r2,34(sp)
 2001000:	1c7fffc4 	addi	r17,r3,-1
 2001004:	00000306 	br	2001014 <___vfprintf_internal_r+0x4e4>
 2001008:	8c7fffc4 	addi	r17,r17,-1
 200100c:	013fffc4 	movi	r4,-1
 2001010:	893fd126 	beq	r17,r4,2000f58 <__alt_data_end+0xfe000f58>
 2001014:	b8800117 	ldw	r2,4(r23)
 2001018:	e009883a 	mov	r4,fp
 200101c:	b80b883a 	mov	r5,r23
 2001020:	d9800884 	addi	r6,sp,34
 2001024:	01c00044 	movi	r7,1
 2001028:	103ee83a 	callr	r2
 200102c:	103ff626 	beq	r2,zero,2001008 <__alt_data_end+0xfe001008>
 2001030:	04bfffc4 	movi	r18,-1
 2001034:	003ef306 	br	2000c04 <__alt_data_end+0xfe000c04>
 2001038:	00800044 	movi	r2,1
 200103c:	d8800b15 	stw	r2,44(sp)
 2001040:	003f2406 	br	2000cd4 <__alt_data_end+0xfe000cd4>
 2001044:	b8c00117 	ldw	r3,4(r23)
 2001048:	d8800905 	stb	r2,36(sp)
 200104c:	e009883a 	mov	r4,fp
 2001050:	b80b883a 	mov	r5,r23
 2001054:	d9800904 	addi	r6,sp,36
 2001058:	a80f883a 	mov	r7,r21
 200105c:	183ee83a 	callr	r3
 2001060:	103f7d1e 	bne	r2,zero,2000e58 <__alt_data_end+0xfe000e58>
 2001064:	94800044 	addi	r18,r18,1
 2001068:	002b883a 	mov	r21,zero
 200106c:	003ecb06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2001070:	00c00044 	movi	r3,1
 2001074:	d8c01315 	stw	r3,76(sp)
 2001078:	05000404 	movi	r20,16
 200107c:	003f7906 	br	2000e64 <__alt_data_end+0xfe000e64>
 2001080:	d8c00c17 	ldw	r3,48(sp)
 2001084:	98c0380e 	bge	r19,r3,2001168 <___vfprintf_internal_r+0x638>
 2001088:	1dbfffc4 	addi	r22,r3,-1
 200108c:	00800804 	movi	r2,32
 2001090:	d8800845 	stb	r2,33(sp)
 2001094:	b023883a 	mov	r17,r22
 2001098:	057fffc4 	movi	r21,-1
 200109c:	8c7fffc4 	addi	r17,r17,-1
 20010a0:	8d403026 	beq	r17,r21,2001164 <___vfprintf_internal_r+0x634>
 20010a4:	b8800117 	ldw	r2,4(r23)
 20010a8:	e009883a 	mov	r4,fp
 20010ac:	b80b883a 	mov	r5,r23
 20010b0:	d9800844 	addi	r6,sp,33
 20010b4:	01c00044 	movi	r7,1
 20010b8:	103ee83a 	callr	r2
 20010bc:	103ff726 	beq	r2,zero,200109c <__alt_data_end+0xfe00109c>
 20010c0:	04bfffc4 	movi	r18,-1
 20010c4:	003ecf06 	br	2000c04 <__alt_data_end+0xfe000c04>
 20010c8:	d9000e17 	ldw	r4,56(sp)
 20010cc:	d8c00e17 	ldw	r3,56(sp)
 20010d0:	21000017 	ldw	r4,0(r4)
 20010d4:	18c00104 	addi	r3,r3,4
 20010d8:	d8c00e15 	stw	r3,56(sp)
 20010dc:	d9000f15 	stw	r4,60(sp)
 20010e0:	20008900 	call	2000890 <strlen>
 20010e4:	d8c00c17 	ldw	r3,48(sp)
 20010e8:	102d883a 	mov	r22,r2
 20010ec:	1887c83a 	sub	r3,r3,r2
 20010f0:	d8c01215 	stw	r3,72(sp)
 20010f4:	00c0110e 	bge	zero,r3,200113c <___vfprintf_internal_r+0x60c>
 20010f8:	00800804 	movi	r2,32
 20010fc:	d8800805 	stb	r2,32(sp)
 2001100:	1c7fffc4 	addi	r17,r3,-1
 2001104:	057fffc4 	movi	r21,-1
 2001108:	00000206 	br	2001114 <___vfprintf_internal_r+0x5e4>
 200110c:	8c7fffc4 	addi	r17,r17,-1
 2001110:	8d400826 	beq	r17,r21,2001134 <___vfprintf_internal_r+0x604>
 2001114:	b8800117 	ldw	r2,4(r23)
 2001118:	e009883a 	mov	r4,fp
 200111c:	b80b883a 	mov	r5,r23
 2001120:	d9800804 	addi	r6,sp,32
 2001124:	01c00044 	movi	r7,1
 2001128:	103ee83a 	callr	r2
 200112c:	103ff726 	beq	r2,zero,200110c <__alt_data_end+0xfe00110c>
 2001130:	003f4906 	br	2000e58 <__alt_data_end+0xfe000e58>
 2001134:	d8c01217 	ldw	r3,72(sp)
 2001138:	90e5883a 	add	r18,r18,r3
 200113c:	b8800117 	ldw	r2,4(r23)
 2001140:	d9800f17 	ldw	r6,60(sp)
 2001144:	e009883a 	mov	r4,fp
 2001148:	b80b883a 	mov	r5,r23
 200114c:	b00f883a 	mov	r7,r22
 2001150:	103ee83a 	callr	r2
 2001154:	103f401e 	bne	r2,zero,2000e58 <__alt_data_end+0xfe000e58>
 2001158:	95a5883a 	add	r18,r18,r22
 200115c:	002b883a 	mov	r21,zero
 2001160:	003e8e06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 2001164:	95a5883a 	add	r18,r18,r22
 2001168:	d9000e17 	ldw	r4,56(sp)
 200116c:	b8800117 	ldw	r2,4(r23)
 2001170:	b80b883a 	mov	r5,r23
 2001174:	20c00017 	ldw	r3,0(r4)
 2001178:	d9800904 	addi	r6,sp,36
 200117c:	e009883a 	mov	r4,fp
 2001180:	d8c00905 	stb	r3,36(sp)
 2001184:	d8c00e17 	ldw	r3,56(sp)
 2001188:	01c00044 	movi	r7,1
 200118c:	1c400104 	addi	r17,r3,4
 2001190:	103ee83a 	callr	r2
 2001194:	103f301e 	bne	r2,zero,2000e58 <__alt_data_end+0xfe000e58>
 2001198:	94800044 	addi	r18,r18,1
 200119c:	dc400e15 	stw	r17,56(sp)
 20011a0:	002b883a 	mov	r21,zero
 20011a4:	003e7d06 	br	2000b9c <__alt_data_end+0xfe000b9c>
 20011a8:	b8800117 	ldw	r2,4(r23)
 20011ac:	00c00b44 	movi	r3,45
 20011b0:	d8c00905 	stb	r3,36(sp)
 20011b4:	e009883a 	mov	r4,fp
 20011b8:	b80b883a 	mov	r5,r23
 20011bc:	d9800904 	addi	r6,sp,36
 20011c0:	01c00044 	movi	r7,1
 20011c4:	103ee83a 	callr	r2
 20011c8:	103f231e 	bne	r2,zero,2000e58 <__alt_data_end+0xfe000e58>
 20011cc:	d8c00f17 	ldw	r3,60(sp)
 20011d0:	94800044 	addi	r18,r18,1
 20011d4:	00ff1216 	blt	zero,r3,2000e20 <__alt_data_end+0xfe000e20>
 20011d8:	003f6d06 	br	2000f90 <__alt_data_end+0xfe000f90>
 20011dc:	05adc83a 	sub	r22,zero,r22
 20011e0:	d8c01215 	stw	r3,72(sp)
 20011e4:	003f2506 	br	2000e7c <__alt_data_end+0xfe000e7c>
 20011e8:	d8c00f17 	ldw	r3,60(sp)
 20011ec:	90e5883a 	add	r18,r18,r3
 20011f0:	003f6706 	br	2000f90 <__alt_data_end+0xfe000f90>

020011f4 <__vfprintf_internal>:
 20011f4:	00808034 	movhi	r2,512
 20011f8:	10883b04 	addi	r2,r2,8428
 20011fc:	2007883a 	mov	r3,r4
 2001200:	11000017 	ldw	r4,0(r2)
 2001204:	2805883a 	mov	r2,r5
 2001208:	300f883a 	mov	r7,r6
 200120c:	180b883a 	mov	r5,r3
 2001210:	100d883a 	mov	r6,r2
 2001214:	2000b301 	jmpi	2000b30 <___vfprintf_internal_r>

02001218 <__sfvwrite_small_dev>:
 2001218:	2880000b 	ldhu	r2,0(r5)
 200121c:	defffa04 	addi	sp,sp,-24
 2001220:	dcc00315 	stw	r19,12(sp)
 2001224:	10c0020c 	andi	r3,r2,8
 2001228:	18ffffcc 	andi	r3,r3,65535
 200122c:	18e0001c 	xori	r3,r3,32768
 2001230:	dc800215 	stw	r18,8(sp)
 2001234:	dc400115 	stw	r17,4(sp)
 2001238:	dfc00515 	stw	ra,20(sp)
 200123c:	dd000415 	stw	r20,16(sp)
 2001240:	dc000015 	stw	r16,0(sp)
 2001244:	18e00004 	addi	r3,r3,-32768
 2001248:	2825883a 	mov	r18,r5
 200124c:	2027883a 	mov	r19,r4
 2001250:	3023883a 	mov	r17,r6
 2001254:	18002626 	beq	r3,zero,20012f0 <__sfvwrite_small_dev+0xd8>
 2001258:	2940008f 	ldh	r5,2(r5)
 200125c:	28001016 	blt	r5,zero,20012a0 <__sfvwrite_small_dev+0x88>
 2001260:	01c01a0e 	bge	zero,r7,20012cc <__sfvwrite_small_dev+0xb4>
 2001264:	3821883a 	mov	r16,r7
 2001268:	05010004 	movi	r20,1024
 200126c:	00000306 	br	200127c <__sfvwrite_small_dev+0x64>
 2001270:	88a3883a 	add	r17,r17,r2
 2001274:	0400150e 	bge	zero,r16,20012cc <__sfvwrite_small_dev+0xb4>
 2001278:	9140008f 	ldh	r5,2(r18)
 200127c:	880d883a 	mov	r6,r17
 2001280:	9809883a 	mov	r4,r19
 2001284:	800f883a 	mov	r7,r16
 2001288:	a400010e 	bge	r20,r16,2001290 <__sfvwrite_small_dev+0x78>
 200128c:	01c10004 	movi	r7,1024
 2001290:	20012f80 	call	20012f8 <_write_r>
 2001294:	80a1c83a 	sub	r16,r16,r2
 2001298:	00bff516 	blt	zero,r2,2001270 <__alt_data_end+0xfe001270>
 200129c:	9080000b 	ldhu	r2,0(r18)
 20012a0:	10801014 	ori	r2,r2,64
 20012a4:	9080000d 	sth	r2,0(r18)
 20012a8:	00bfffc4 	movi	r2,-1
 20012ac:	dfc00517 	ldw	ra,20(sp)
 20012b0:	dd000417 	ldw	r20,16(sp)
 20012b4:	dcc00317 	ldw	r19,12(sp)
 20012b8:	dc800217 	ldw	r18,8(sp)
 20012bc:	dc400117 	ldw	r17,4(sp)
 20012c0:	dc000017 	ldw	r16,0(sp)
 20012c4:	dec00604 	addi	sp,sp,24
 20012c8:	f800283a 	ret
 20012cc:	0005883a 	mov	r2,zero
 20012d0:	dfc00517 	ldw	ra,20(sp)
 20012d4:	dd000417 	ldw	r20,16(sp)
 20012d8:	dcc00317 	ldw	r19,12(sp)
 20012dc:	dc800217 	ldw	r18,8(sp)
 20012e0:	dc400117 	ldw	r17,4(sp)
 20012e4:	dc000017 	ldw	r16,0(sp)
 20012e8:	dec00604 	addi	sp,sp,24
 20012ec:	f800283a 	ret
 20012f0:	00bfffc4 	movi	r2,-1
 20012f4:	003fed06 	br	20012ac <__alt_data_end+0xfe0012ac>

020012f8 <_write_r>:
 20012f8:	defffd04 	addi	sp,sp,-12
 20012fc:	dc400115 	stw	r17,4(sp)
 2001300:	dc000015 	stw	r16,0(sp)
 2001304:	2023883a 	mov	r17,r4
 2001308:	04008034 	movhi	r16,512
 200130c:	8408b304 	addi	r16,r16,8908
 2001310:	2809883a 	mov	r4,r5
 2001314:	300b883a 	mov	r5,r6
 2001318:	380d883a 	mov	r6,r7
 200131c:	dfc00215 	stw	ra,8(sp)
 2001320:	80000015 	stw	zero,0(r16)
 2001324:	20016080 	call	2001608 <write>
 2001328:	00ffffc4 	movi	r3,-1
 200132c:	10c00526 	beq	r2,r3,2001344 <_write_r+0x4c>
 2001330:	dfc00217 	ldw	ra,8(sp)
 2001334:	dc400117 	ldw	r17,4(sp)
 2001338:	dc000017 	ldw	r16,0(sp)
 200133c:	dec00304 	addi	sp,sp,12
 2001340:	f800283a 	ret
 2001344:	80c00017 	ldw	r3,0(r16)
 2001348:	183ff926 	beq	r3,zero,2001330 <__alt_data_end+0xfe001330>
 200134c:	88c00015 	stw	r3,0(r17)
 2001350:	dfc00217 	ldw	ra,8(sp)
 2001354:	dc400117 	ldw	r17,4(sp)
 2001358:	dc000017 	ldw	r16,0(sp)
 200135c:	dec00304 	addi	sp,sp,12
 2001360:	f800283a 	ret

02001364 <udivmodsi4>:
 2001364:	2005883a 	mov	r2,r4
 2001368:	2900182e 	bgeu	r5,r4,20013cc <udivmodsi4+0x68>
 200136c:	28001716 	blt	r5,zero,20013cc <udivmodsi4+0x68>
 2001370:	01000804 	movi	r4,32
 2001374:	00c00044 	movi	r3,1
 2001378:	00000206 	br	2001384 <udivmodsi4+0x20>
 200137c:	20001126 	beq	r4,zero,20013c4 <udivmodsi4+0x60>
 2001380:	28000516 	blt	r5,zero,2001398 <udivmodsi4+0x34>
 2001384:	294b883a 	add	r5,r5,r5
 2001388:	213fffc4 	addi	r4,r4,-1
 200138c:	18c7883a 	add	r3,r3,r3
 2001390:	28bffa36 	bltu	r5,r2,200137c <__alt_data_end+0xfe00137c>
 2001394:	18000b26 	beq	r3,zero,20013c4 <udivmodsi4+0x60>
 2001398:	0009883a 	mov	r4,zero
 200139c:	11400236 	bltu	r2,r5,20013a8 <udivmodsi4+0x44>
 20013a0:	1145c83a 	sub	r2,r2,r5
 20013a4:	20c8b03a 	or	r4,r4,r3
 20013a8:	1806d07a 	srli	r3,r3,1
 20013ac:	280ad07a 	srli	r5,r5,1
 20013b0:	183ffa1e 	bne	r3,zero,200139c <__alt_data_end+0xfe00139c>
 20013b4:	3000021e 	bne	r6,zero,20013c0 <udivmodsi4+0x5c>
 20013b8:	2005883a 	mov	r2,r4
 20013bc:	f800283a 	ret
 20013c0:	f800283a 	ret
 20013c4:	0009883a 	mov	r4,zero
 20013c8:	003ffa06 	br	20013b4 <__alt_data_end+0xfe0013b4>
 20013cc:	00c00044 	movi	r3,1
 20013d0:	0009883a 	mov	r4,zero
 20013d4:	003ff106 	br	200139c <__alt_data_end+0xfe00139c>

020013d8 <__divsi3>:
 20013d8:	defffe04 	addi	sp,sp,-8
 20013dc:	dfc00115 	stw	ra,4(sp)
 20013e0:	dc000015 	stw	r16,0(sp)
 20013e4:	20000a16 	blt	r4,zero,2001410 <__divsi3+0x38>
 20013e8:	0021883a 	mov	r16,zero
 20013ec:	28000b16 	blt	r5,zero,200141c <__divsi3+0x44>
 20013f0:	000d883a 	mov	r6,zero
 20013f4:	20013640 	call	2001364 <udivmodsi4>
 20013f8:	80000126 	beq	r16,zero,2001400 <__divsi3+0x28>
 20013fc:	0085c83a 	sub	r2,zero,r2
 2001400:	dfc00117 	ldw	ra,4(sp)
 2001404:	dc000017 	ldw	r16,0(sp)
 2001408:	dec00204 	addi	sp,sp,8
 200140c:	f800283a 	ret
 2001410:	0109c83a 	sub	r4,zero,r4
 2001414:	04000044 	movi	r16,1
 2001418:	283ff50e 	bge	r5,zero,20013f0 <__alt_data_end+0xfe0013f0>
 200141c:	014bc83a 	sub	r5,zero,r5
 2001420:	8400005c 	xori	r16,r16,1
 2001424:	003ff206 	br	20013f0 <__alt_data_end+0xfe0013f0>

02001428 <__modsi3>:
 2001428:	deffff04 	addi	sp,sp,-4
 200142c:	dfc00015 	stw	ra,0(sp)
 2001430:	20000516 	blt	r4,zero,2001448 <__modsi3+0x20>
 2001434:	28000c16 	blt	r5,zero,2001468 <__modsi3+0x40>
 2001438:	01800044 	movi	r6,1
 200143c:	dfc00017 	ldw	ra,0(sp)
 2001440:	dec00104 	addi	sp,sp,4
 2001444:	20013641 	jmpi	2001364 <udivmodsi4>
 2001448:	0109c83a 	sub	r4,zero,r4
 200144c:	28000b16 	blt	r5,zero,200147c <__modsi3+0x54>
 2001450:	01800044 	movi	r6,1
 2001454:	20013640 	call	2001364 <udivmodsi4>
 2001458:	0085c83a 	sub	r2,zero,r2
 200145c:	dfc00017 	ldw	ra,0(sp)
 2001460:	dec00104 	addi	sp,sp,4
 2001464:	f800283a 	ret
 2001468:	014bc83a 	sub	r5,zero,r5
 200146c:	01800044 	movi	r6,1
 2001470:	dfc00017 	ldw	ra,0(sp)
 2001474:	dec00104 	addi	sp,sp,4
 2001478:	20013641 	jmpi	2001364 <udivmodsi4>
 200147c:	014bc83a 	sub	r5,zero,r5
 2001480:	003ff306 	br	2001450 <__alt_data_end+0xfe001450>

02001484 <__udivsi3>:
 2001484:	000d883a 	mov	r6,zero
 2001488:	20013641 	jmpi	2001364 <udivmodsi4>

0200148c <__umodsi3>:
 200148c:	01800044 	movi	r6,1
 2001490:	20013641 	jmpi	2001364 <udivmodsi4>

02001494 <alt_getchar>:
{
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
 2001494:	00808034 	movhi	r2,512
 2001498:	10882304 	addi	r2,r2,8332
 200149c:	11c00217 	ldw	r7,8(r2)
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
 20014a0:	defffe04 	addi	sp,sp,-8
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
 20014a4:	01008034 	movhi	r4,512
 20014a8:	21083d04 	addi	r4,r4,8436
 20014ac:	d80b883a 	mov	r5,sp
 20014b0:	01800044 	movi	r6,1
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
 20014b4:	dfc00115 	stw	ra,4(sp)
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
 20014b8:	20016d00 	call	20016d0 <altera_avalon_jtag_uart_read>
 20014bc:	0080020e 	bge	zero,r2,20014c8 <alt_getchar+0x34>
        return -1;
    }
    return c;
 20014c0:	d8800007 	ldb	r2,0(sp)
 20014c4:	00000106 	br	20014cc <alt_getchar+0x38>
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
        return -1;
 20014c8:	00bfffc4 	movi	r2,-1
    }
    return c;
#else
    return getchar();
#endif
}
 20014cc:	dfc00117 	ldw	ra,4(sp)
 20014d0:	dec00204 	addi	sp,sp,8
 20014d4:	f800283a 	ret

020014d8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 20014d8:	deffff04 	addi	sp,sp,-4
 20014dc:	dfc00015 	stw	ra,0(sp)
 20014e0:	00c08034 	movhi	r3,512
 20014e4:	18c7d504 	addi	r3,r3,8020
 20014e8:	01008034 	movhi	r4,512
 20014ec:	21084404 	addi	r4,r4,8464

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 20014f0:	1900061e 	bne	r3,r4,200150c <alt_load+0x34>
 20014f4:	00c08034 	movhi	r3,512
 20014f8:	18c00804 	addi	r3,r3,32
 20014fc:	01008034 	movhi	r4,512
 2001500:	21000804 	addi	r4,r4,32
 2001504:	1900151e 	bne	r3,r4,200155c <alt_load+0x84>
 2001508:	00000e06 	br	2001544 <alt_load+0x6c>
 * alt_load() is called when the code is executing from flash. In this case
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
 200150c:	01408034 	movhi	r5,512
 2001510:	29484404 	addi	r5,r5,8464
 2001514:	00bfff04 	movi	r2,-4
 2001518:	28cbc83a 	sub	r5,r5,r3
 200151c:	288a703a 	and	r5,r5,r2
 2001520:	0005883a 	mov	r2,zero
 2001524:	00000506 	br	200153c <alt_load+0x64>
 2001528:	208f883a 	add	r7,r4,r2
  {
    while( to != end )
    {
      *to++ = *from++;
 200152c:	39c00017 	ldw	r7,0(r7)
 2001530:	188d883a 	add	r6,r3,r2
 2001534:	10800104 	addi	r2,r2,4
 2001538:	31c00015 	stw	r7,0(r6)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 200153c:	117ffa1e 	bne	r2,r5,2001528 <__alt_data_end+0xfe001528>
 2001540:	003fec06 	br	20014f4 <__alt_data_end+0xfe0014f4>
 2001544:	00c08034 	movhi	r3,512
 2001548:	18c60e04 	addi	r3,r3,6200
 200154c:	01008034 	movhi	r4,512
 2001550:	21060e04 	addi	r4,r4,6200

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 2001554:	1900131e 	bne	r3,r4,20015a4 <alt_load+0xcc>
 2001558:	00000e06 	br	2001594 <alt_load+0xbc>
 200155c:	01408034 	movhi	r5,512
 2001560:	29400804 	addi	r5,r5,32
 2001564:	00bfff04 	movi	r2,-4
 2001568:	28cbc83a 	sub	r5,r5,r3
 200156c:	288a703a 	and	r5,r5,r2
 2001570:	0005883a 	mov	r2,zero
 2001574:	00000506 	br	200158c <alt_load+0xb4>
 2001578:	208f883a 	add	r7,r4,r2
  {
    while( to != end )
    {
      *to++ = *from++;
 200157c:	39c00017 	ldw	r7,0(r7)
 2001580:	188d883a 	add	r6,r3,r2
 2001584:	10800104 	addi	r2,r2,4
 2001588:	31c00015 	stw	r7,0(r6)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 200158c:	117ffa1e 	bne	r2,r5,2001578 <__alt_data_end+0xfe001578>
 2001590:	003fec06 	br	2001544 <__alt_data_end+0xfe001544>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 2001594:	20017600 	call	2001760 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 2001598:	dfc00017 	ldw	ra,0(sp)
 200159c:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 20015a0:	20017ec1 	jmpi	20017ec <alt_icache_flush_all>
 * alt_load() is called when the code is executing from flash. In this case
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
 20015a4:	01408034 	movhi	r5,512
 20015a8:	2947d504 	addi	r5,r5,8020
 20015ac:	00bfff04 	movi	r2,-4
 20015b0:	28cbc83a 	sub	r5,r5,r3
 20015b4:	288a703a 	and	r5,r5,r2
 20015b8:	0005883a 	mov	r2,zero
 20015bc:	00000506 	br	20015d4 <alt_load+0xfc>
 20015c0:	208f883a 	add	r7,r4,r2
    {
      *to++ = *from++;
 20015c4:	39c00017 	ldw	r7,0(r7)
 20015c8:	188d883a 	add	r6,r3,r2
 20015cc:	10800104 	addi	r2,r2,4
 20015d0:	31c00015 	stw	r7,0(r6)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 20015d4:	117ffa1e 	bne	r2,r5,20015c0 <__alt_data_end+0xfe0015c0>
 20015d8:	003fee06 	br	2001594 <__alt_data_end+0xfe001594>

020015dc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 20015dc:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 20015e0:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 20015e4:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 20015e8:	20016700 	call	2001670 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 20015ec:	20016900 	call	2001690 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 20015f0:	d1207d17 	ldw	r4,-32268(gp)
 20015f4:	d1607c17 	ldw	r5,-32272(gp)
 20015f8:	d1a07b17 	ldw	r6,-32276(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 20015fc:	dfc00017 	ldw	ra,0(sp)
 2001600:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 2001604:	20001081 	jmpi	2000108 <main>

02001608 <write>:
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 2001608:	deffff04 	addi	sp,sp,-4
 200160c:	dfc00015 	stw	ra,0(sp)
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
 2001610:	00800044 	movi	r2,1
 2001614:	20800226 	beq	r4,r2,2001620 <write+0x18>
 2001618:	00800084 	movi	r2,2
 200161c:	2080061e 	bne	r4,r2,2001638 <write+0x30>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
 2001620:	01008034 	movhi	r4,512
 2001624:	21083d04 	addi	r4,r4,8436
 2001628:	000f883a 	mov	r7,zero
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
        return -1;
    }
}
 200162c:	dfc00017 	ldw	ra,0(sp)
 2001630:	dec00104 	addi	sp,sp,4
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
 2001634:	200172c1 	jmpi	200172c <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
 2001638:	00808034 	movhi	r2,512
 200163c:	10884304 	addi	r2,r2,8460
 2001640:	10800017 	ldw	r2,0(r2)
 2001644:	10000226 	beq	r2,zero,2001650 <write+0x48>
 2001648:	103ee83a 	callr	r2
 200164c:	00000206 	br	2001658 <write+0x50>
 2001650:	00808034 	movhi	r2,512
 2001654:	1088b304 	addi	r2,r2,8908
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
 2001658:	00c01444 	movi	r3,81
 200165c:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
 2001660:	00bfffc4 	movi	r2,-1
 2001664:	dfc00017 	ldw	ra,0(sp)
 2001668:	dec00104 	addi	sp,sp,4
 200166c:	f800283a 	ret

02001670 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 2001670:	deffff04 	addi	sp,sp,-4
 2001674:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 2001678:	20017f80 	call	20017f8 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 200167c:	00800044 	movi	r2,1
 2001680:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 2001684:	dfc00017 	ldw	ra,0(sp)
 2001688:	dec00104 	addi	sp,sp,4
 200168c:	f800283a 	ret

02001690 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 2001690:	defffe04 	addi	sp,sp,-8
 2001694:	dc000015 	stw	r16,0(sp)

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 2001698:	04008034 	movhi	r16,512
 200169c:	84083f04 	addi	r16,r16,8444
 20016a0:	800b883a 	mov	r5,r16
 20016a4:	01008034 	movhi	r4,512
 20016a8:	21080d04 	addi	r4,r4,8244
 20016ac:	dfc00115 	stw	ra,4(sp)
 20016b0:	20017800 	call	2001780 <alt_dev_llist_insert>
 20016b4:	01008034 	movhi	r4,512
 20016b8:	21081804 	addi	r4,r4,8288
 20016bc:	800b883a 	mov	r5,r16
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( GREEN_LEDS, Green_LEDs);
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( PUSHBUTTONS, Pushbuttons);
}
 20016c0:	dfc00117 	ldw	ra,4(sp)
 20016c4:	dc000017 	ldw	r16,0(sp)
 20016c8:	dec00204 	addi	sp,sp,8
 20016cc:	20017801 	jmpi	2001780 <alt_dev_llist_insert>

020016d0 <altera_avalon_jtag_uart_read>:

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  unsigned int base = sp->base;
 20016d0:	21000017 	ldw	r4,0(r4)

  char * ptr = buffer;
  char * end = buffer + space;
 20016d4:	298d883a 	add	r6,r5,r6

  while (ptr < end)
 20016d8:	2805883a 	mov	r2,r5

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
 20016dc:	3a10000c 	andi	r8,r7,16384
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
 20016e0:	00000a06 	br	200170c <altera_avalon_jtag_uart_read+0x3c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 20016e4:	20c00037 	ldwio	r3,0(r4)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
 20016e8:	1a60000c 	andi	r9,r3,32768
 20016ec:	48000326 	beq	r9,zero,20016fc <altera_avalon_jtag_uart_read+0x2c>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 20016f0:	10c00005 	stb	r3,0(r2)
 20016f4:	10800044 	addi	r2,r2,1
 20016f8:	00000406 	br	200170c <altera_avalon_jtag_uart_read+0x3c>
    else if (ptr != buffer)
 20016fc:	11400226 	beq	r2,r5,2001708 <altera_avalon_jtag_uart_read+0x38>
      break;   
    
  }

  if (ptr != buffer)
    return ptr - buffer;
 2001700:	1145c83a 	sub	r2,r2,r5
 2001704:	f800283a 	ret

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
 2001708:	4000021e 	bne	r8,zero,2001714 <altera_avalon_jtag_uart_read+0x44>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
 200170c:	11bff536 	bltu	r2,r6,20016e4 <__alt_data_end+0xfe0016e4>
    else if(flags & O_NONBLOCK)
      break;   
    
  }

  if (ptr != buffer)
 2001710:	117ffb1e 	bne	r2,r5,2001700 <__alt_data_end+0xfe001700>
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
 2001714:	39d0000c 	andi	r7,r7,16384
 2001718:	38000226 	beq	r7,zero,2001724 <altera_avalon_jtag_uart_read+0x54>
    return -EWOULDBLOCK;
 200171c:	00bffd44 	movi	r2,-11
 2001720:	f800283a 	ret
  else
    return -EIO;
 2001724:	00bffec4 	movi	r2,-5
}
 2001728:	f800283a 	ret

0200172c <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
 200172c:	20c00017 	ldw	r3,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 2001730:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
 2001734:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 2001738:	19800104 	addi	r6,r3,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 200173c:	00000606 	br	2001758 <altera_avalon_jtag_uart_write+0x2c>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 2001740:	31c00037 	ldwio	r7,0(r6)
 2001744:	39ffffec 	andhi	r7,r7,65535
 2001748:	383ffd26 	beq	r7,zero,2001740 <__alt_data_end+0xfe001740>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
 200174c:	29c00007 	ldb	r7,0(r5)
 2001750:	29400044 	addi	r5,r5,1
 2001754:	19c00035 	stwio	r7,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 2001758:	293ff936 	bltu	r5,r4,2001740 <__alt_data_end+0xfe001740>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
 200175c:	f800283a 	ret

02001760 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 2001760:	0005883a 	mov	r2,zero
 2001764:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 2001768:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 200176c:	10800804 	addi	r2,r2,32
 2001770:	10fffd1e 	bne	r2,r3,2001768 <__alt_data_end+0xfe001768>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 2001774:	f800283a 	ret

02001778 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
 2001778:	3005883a 	mov	r2,r6
 200177c:	f800283a 	ret

02001780 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 2001780:	deffff04 	addi	sp,sp,-4
 2001784:	dfc00015 	stw	ra,0(sp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 2001788:	20000226 	beq	r4,zero,2001794 <alt_dev_llist_insert+0x14>
 200178c:	20800217 	ldw	r2,8(r4)
 2001790:	10000c1e 	bne	r2,zero,20017c4 <alt_dev_llist_insert+0x44>
 2001794:	00808034 	movhi	r2,512
 2001798:	10884304 	addi	r2,r2,8460
 200179c:	10800017 	ldw	r2,0(r2)
 20017a0:	10000226 	beq	r2,zero,20017ac <alt_dev_llist_insert+0x2c>
 20017a4:	103ee83a 	callr	r2
 20017a8:	00000206 	br	20017b4 <alt_dev_llist_insert+0x34>
 20017ac:	00808034 	movhi	r2,512
 20017b0:	1088b304 	addi	r2,r2,8908
  {
    ALT_ERRNO = EINVAL;
 20017b4:	00c00584 	movi	r3,22
 20017b8:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
 20017bc:	00bffa84 	movi	r2,-22
 20017c0:	00000706 	br	20017e0 <alt_dev_llist_insert+0x60>

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
 20017c4:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 20017c8:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
 20017cc:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
 20017d0:	28800017 	ldw	r2,0(r5)
  list->next           = entry;
 20017d4:	29000015 	stw	r4,0(r5)
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
 20017d8:	11000115 	stw	r4,4(r2)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
 20017dc:	0005883a 	mov	r2,zero
}
 20017e0:	dfc00017 	ldw	ra,0(sp)
 20017e4:	dec00104 	addi	sp,sp,4
 20017e8:	f800283a 	ret

020017ec <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 20017ec:	0009883a 	mov	r4,zero
 20017f0:	01440004 	movi	r5,4096
 20017f4:	20018001 	jmpi	2001800 <alt_icache_flush>

020017f8 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 20017f8:	000170fa 	wrctl	ienable,zero
 20017fc:	f800283a 	ret

02001800 <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
 2001800:	00840004 	movi	r2,4096
 2001804:	1140012e 	bgeu	r2,r5,200180c <alt_icache_flush+0xc>
 2001808:	100b883a 	mov	r5,r2
 200180c:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 2001810:	2005883a 	mov	r2,r4
 2001814:	00000206 	br	2001820 <alt_icache_flush+0x20>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 2001818:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 200181c:	10800804 	addi	r2,r2,32
 2001820:	117ffd36 	bltu	r2,r5,2001818 <__alt_data_end+0xfe001818>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 2001824:	210007cc 	andi	r4,r4,31
 2001828:	20000126 	beq	r4,zero,2001830 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 200182c:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 2001830:	0000203a 	flushp
 2001834:	f800283a 	ret
